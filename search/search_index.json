{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>\ufe0fStatus: Early Stage Public Preview</p> <p>A2UI is currently in v0.8 (Public Preview). The specification and implementations are functional but are still evolving. We are opening the project to foster collaboration, gather feedback, and solicit contributions (e.g., on client renderers). Expect changes.</p>"},{"location":"#a-protocol-for-agent-driven-interfaces","title":"A Protocol for Agent-Driven Interfaces","text":"<p> A2UI enables AI agents to generate rich, interactive user interfaces that render natively across web, mobile, and desktop\u2014without executing arbitrary code. </p>"},{"location":"#at-a-glance","title":"At a Glance","text":"<p>A2UI is currently v0.8, Apache 2.0 licensed, created by Google with contributions from CopilotKit and the open source community, and is in active development on GitHub.</p> <p>The problem A2UI solves is: how can AI agents safely send rich UIs across trust boundaries?</p> <p>Instead of text-only responses or risky code execution, A2UI lets agents send declarative component descriptions that clients render using their own native widgets. It's like having agents speak a universal UI language.</p> <p>In this repo you will find A2UI specifications and implementations for renderers (eg: Angular, Flutter, etc.) on the client side, and transports (eg: A2A, etc.) which communicate A2UI messages between agents and clients.</p> <ul> <li> <p> Secure by Design</p> <p>Declarative data format, not executable code. Agents can only use pre-approved components from your catalog\u2014no UI injection attacks.</p> </li> <li> <p> LLM-Friendly</p> <p>Flat, streaming JSON structure designed for easy generation. LLMs can build UIs incrementally without perfect JSON in one shot.</p> </li> <li> <p> Framework-Agnostic</p> <p>One agent response works everywhere. Render the same UI on Angular, Flutter, React, or native mobile with your own styled components.</p> </li> <li> <p> Progressive Rendering</p> <p>Stream UI updates as they're generated. Users see the interface building in real-time instead of waiting for complete responses.</p> </li> </ul>"},{"location":"#get-started-in-5-minutes","title":"Get Started in 5 Minutes","text":"<ul> <li> <p> Quickstart Guide</p> <p>Run the restaurant finder demo and see A2UI in action with Gemini-powered agents.</p> <p> Get started</p> </li> <li> <p> Core Concepts</p> <p>Understand surfaces, components, data binding, and the adjacency list model.</p> <p> Learn concepts</p> </li> <li> <p> Developer Guides</p> <p>Integrate A2UI renderers into your app or build agents that generate UIs.</p> <p> Start building</p> </li> <li> <p> Protocol Reference</p> <p>Dive into the complete technical specification and message types.</p> <p> Read the spec</p> </li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>User sends a message to an AI agent</li> <li>Agent generates A2UI messages describing the UI (structure + data)</li> <li>Messages stream to the client application</li> <li>Client renders using native components (Angular, Flutter, React, etc.)</li> <li>User interacts with the UI, sending actions back to the agent</li> <li>Agent responds with updated A2UI messages</li> </ol>"},{"location":"#a2ui-in-action","title":"A2UI in Action","text":""},{"location":"#landscape-architect-demo","title":"Landscape Architect Demo","text":"Your browser does not support the video tag.      <p>     Watch an agent generate all of the interfaces for a landscape architect application. The user uploads a photo; the agent uses Gemini to understand it and generate a custom form for landscaping needs.   </p>"},{"location":"#custom-components-interactive-charts-maps","title":"Custom Components: Interactive Charts &amp; Maps","text":"Your browser does not support the video tag.      <p>     Watch an agent chose to respond with a chart component to answer a numberical summary quesiton.  Then the agent chooses a Google Map component to answer a location question.  Both are custom components offered by the client.   </p>"},{"location":"#a2ui-composer","title":"A2UI Composer","text":"<p>CopilotKit has a public A2UI Widget Builder to try out as well.</p> <p></p>"},{"location":"agents/","title":"Agents (Server-Side)","text":"<p>Agents are server-side programs that generate A2UI messages in response to user requests.</p> <p>The actual component rendering is done by the renderer, after messages are transported to the client. The agent is only responsible for generating the A2UI messages.</p>"},{"location":"agents/#how-agents-work","title":"How Agents Work","text":"<pre><code>User Input \u2192 Agent Logic \u2192 LLM \u2192 A2UI JSON \u2192 Send to Client\n</code></pre> <ol> <li>Receive user message</li> <li>Process with LLM (Gemini, GPT, Claude, etc.)</li> <li>Generate A2UI JSON messages as structured output</li> <li>Send to client via transport</li> </ol> <p>User interactions from the client can be treated as new user input.</p>"},{"location":"agents/#sample-agents","title":"Sample Agents","text":"<p>The A2UI repository includes sample agents you can learn from:</p> <ul> <li>Restaurant Finder <ul> <li>Table reservations with forms</li> <li>Written with the ADK</li> </ul> </li> <li>Contact Lookup <ul> <li>Search with result lists</li> <li>Written with the ADK</li> </ul> </li> <li>Rizzcharts <ul> <li>A2UI Custom components demo</li> <li>Written with the ADK</li> </ul> </li> </ul>"},{"location":"agents/#different-types-of-agents-you-will-use-a2a-with","title":"Different types of agents you will use A2A with","text":""},{"location":"agents/#1-user-facing-agent-standalone","title":"1. User Facing Agent (standalone)","text":"<p>A user facing agent is one that is directly interacted with by the user. </p>"},{"location":"agents/#2-user-facing-agent-as-a-host-for-a-remote-agent","title":"2. User Facing Agent as a host for a Remote Agent","text":"<p>This is a pattern where the user facing agent is a host for one or more remote agents. The user facing agent will call the remote agent and the remote agent will generate the A2UI messages. This is a common pattern in A2A with the client agent calling the server agent.</p> <ul> <li>The user facing agent may \"passthrough\" the A2UI message without altering them</li> <li>The user facing agent may alter the A2UI message before sending it to the client</li> </ul>"},{"location":"agents/#3-remote-agent","title":"3. Remote Agent","text":"<p>A remote agent is not directly a part of the user facing UI. Instead it is registered in as a remote agent and can be called by the user facing agent. This is a common pattern in A2A with the client agent calling the server agent.</p>"},{"location":"community/","title":"Community","text":"<p>Welcome to the A2UI community! We're building the future of agent-driven interfaces together.</p>"},{"location":"community/#get-involved","title":"Get Involved","text":"<p>A2UI is an open-source project licensed under Apache 2.0. We welcome contributions from developers, researchers, and anyone interested in advancing agentic user interfaces.</p>"},{"location":"community/#community-showcase","title":"Community Showcase","text":"<p>Coming soon...</p> <p>We are considering how best to showcase community projects, examples, themes, renderers, custom components, and more.  A 4 minute (or less) demo video and code sample linked in Github discussions is a great way to show off your work.</p>"},{"location":"community/#project-partners","title":"Project Partners","text":"<p>A2UI is developed in collaboration with several organizations:</p>"},{"location":"community/#google-opal","title":"Google Opal","text":"<p>Opal lets users build, edit, and share AI mini-apps using natural language. The Opal team has been a core contributor to A2UI's development.</p>"},{"location":"community/#flutter","title":"Flutter","text":"<p>The GenUI SDK for Flutter uses A2UI as the UI declaration format for generating dynamic, personalized UIs in Flutter applications.</p>"},{"location":"community/#gemini-enterprise","title":"Gemini Enterprise","text":"<p>A2UI is being integrated into Gemini Enterprise to enable custom agents to render rich, interactive UIs within enterprise applications.</p>"},{"location":"community/#ag-ui-copilotkit","title":"AG UI / CopilotKit","text":"<p>AG UI and CopilotKit provide day-zero compatibility with A2UI, enabling developers to build rich, state-synced applications that render dynamic UIs from agents.</p>"},{"location":"community/#a2a","title":"A2A","text":"<p>Google's A2A team have been core contributors to A2UI's development, with support from the A2A Technical Steering Committee (TSC).</p>"},{"location":"community/#and-more","title":"... and more","text":"<p>There are many organizations and individuals contributing to A2UI's development.</p> <p>If you have made signiciant contributions to A2UI, please submit your name to this list.</p>"},{"location":"community/#code-of-conduct","title":"Code of Conduct","text":"<p>We are committed to providing a welcoming and inclusive environment for everyone. All participants are expected to:</p> <ul> <li>Be respectful and considerate</li> <li>Welcome newcomers and help them get started</li> <li>Focus on what's best for the community</li> <li>Show empathy towards others</li> </ul> <p>Unacceptable behavior will not be tolerated. Report concerns to the project maintainers.</p>"},{"location":"community/#recognition","title":"Recognition","text":"<p>We appreciate all contributions! Contributors are recognized in:</p> <ul> <li>GitHub's contributor graph</li> <li>Release notes</li> <li>Project acknowledgments</li> </ul> <p>Significant contributors may be invited to join the project's maintainer team.</p>"},{"location":"community/#stay-updated","title":"Stay Updated","text":"<ul> <li>Watch the GitHub repo for notifications</li> <li>Star the repo to bookmark and show support</li> <li>Follow releases to get notified of new versions</li> </ul>"},{"location":"community/#ways-to-contribute","title":"Ways to Contribute","text":"<p>github.com/google/A2UI</p> <ul> <li>Report Issues: Found a bug? Open an issue</li> <li>Build Renderers: See the roadmap for planned frameworks</li> <li>Share Examples: Post with <code>#A2UI</code> on X/LinkedIn, start a discussion</li> <li>Improve Docs: PRs welcome in the <code>docs/</code> directory</li> </ul>"},{"location":"community/#questions","title":"Questions?","text":"<ul> <li>Check the documentation</li> <li>Search GitHub Discussions</li> <li>Ask in GitHub Issues</li> </ul> <p>Thank you for being part of the A2UI community!</p>"},{"location":"composer/","title":"A2UI Composer","text":"<p>Try building A2UI widgets interactively with the CopilotKit A2UI Widget Builder.</p> <p></p> <p>Launch Widget Builder \u2192</p>"},{"location":"composer/#what-it-does","title":"What it does","text":"<ul> <li>Experiment with A2UI components visually</li> <li>Generate A2UI JSON by describing what you want</li> <li>See real-time previews</li> <li>Copy JSON to use in your agents</li> </ul> <p>Built by the CopilotKit team.</p>"},{"location":"quickstart/","title":"Quickstart: Run A2UI in 5 Minutes","text":"<p>Get hands-on with A2UI by running the restaurant finder demo. This guide will have you experiencing agent-generated UI in less than 5 minutes.</p>"},{"location":"quickstart/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this quickstart, you'll have:</p> <ul> <li>\u2705 A running web app with A2UI Lit renderer</li> <li>\u2705 A Gemini-powered agent that generates dynamic UIs</li> <li>\u2705 An interactive restaurant finder with form generation, time selection, and confirmation flows</li> <li>\u2705 Understanding of how A2UI messages flow from agent to UI</li> </ul>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Node.js (v18 or later) - Download here</li> <li>A Gemini API key - Get one free from Google AI Studio</li> </ul> <p>Security Notice</p> <p>This demo runs an A2A agent that uses Gemini to generate A2UI responses. The agent has access to your API key and will make requests to Google's Gemini API. Always review agent code before running it in production environments.</p>"},{"location":"quickstart/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<pre><code>git clone https://github.com/google/a2ui.git\ncd a2ui\n</code></pre>"},{"location":"quickstart/#step-2-set-your-api-key","title":"Step 2: Set Your API Key","text":"<p>Export your Gemini API key as an environment variable:</p> <pre><code>export GEMINI_API_KEY=\"your_gemini_api_key_here\"\n</code></pre>"},{"location":"quickstart/#step-3-navigate-to-the-lit-client","title":"Step 3: Navigate to the Lit Client","text":"<pre><code>cd samples/client/lit\n</code></pre>"},{"location":"quickstart/#step-4-install-and-run","title":"Step 4: Install and Run","text":"<p>Run the one-command demo launcher:</p> <pre><code>npm install\nnpm run demo:all\n</code></pre> <p>This command will:</p> <ol> <li>Install all dependencies</li> <li>Build the A2UI renderer</li> <li>Start the A2A restaurant finder agent (Python backend)</li> <li>Launch the development server</li> <li>Open your browser to <code>http://localhost:5173</code></li> </ol> <p>Demo Running</p> <p>If everything worked, you should see the web app in your browser. The agent is now ready to generate UI!</p>"},{"location":"quickstart/#step-5-try-it-out","title":"Step 5: Try It Out","text":"<p>In the web app, try these prompts:</p> <ol> <li>\"Book a table for 2\" - Watch the agent generate a reservation form</li> <li>\"Find Italian restaurants near me\" - See dynamic search results</li> <li>\"What are your hours?\" - Experience different UI layouts for different intents</li> </ol>"},{"location":"quickstart/#whats-happening-behind-the-scenes","title":"What's Happening Behind the Scenes","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   You Type  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502 A2A Agent    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502  Gemini API    \u2502\n\u2502  a Message  \u2502         \u2502  (Python)    \u2502         \u2502  (LLM)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502                         \u2502\n                               \u2502 Generates A2UI JSON     \u2502\n                               \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u2502 Streams JSONL messages\n                               v\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502   Web App    \u2502\n                        \u2502 (A2UI Lit    \u2502\n                        \u2502  Renderer)   \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u2502 Renders native components\n                               v\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502   Your UI    \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>You send a message via the web UI</li> <li>The A2A agent receives it and sends the conversation to Gemini</li> <li>Gemini generates A2UI JSON messages describing the UI</li> <li>The A2A agent streams these messages back to the web app</li> <li>The A2UI renderer converts them into native web components</li> <li>You see the UI rendered in your browser</li> </ol>"},{"location":"quickstart/#anatomy-of-an-a2ui-message","title":"Anatomy of an A2UI Message","text":"<p>Let's peek at what the agent is sending. Here's a simplified example of the JSON messages:</p>"},{"location":"quickstart/#defining-the-ui","title":"Defining the UI","text":"<pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main\",\n    \"components\": [\n      {\n        \"id\": \"header\",\n        \"component\": {\n          \"Text\": {\n            \"text\": {\"literalString\": \"Book Your Table\"},\n            \"usageHint\": \"h1\"\n          }\n        }\n      },\n      {\n        \"id\": \"date-picker\",\n        \"component\": {\n          \"DateTimeInput\": {\n            \"label\": {\"literalString\": \"Select Date\"},\n            \"value\": {\"path\": \"/reservation/date\"},\n            \"enableDate\": true\n          }\n        }\n      },\n      {\n        \"id\": \"submit-btn\",\n        \"component\": {\n          \"Button\": {\n            \"child\": \"submit-text\",\n            \"action\": {\"name\": \"confirm_booking\"}\n          }\n        }\n      },\n      {\n        \"id\": \"submit-text\",\n        \"component\": {\n          \"Text\": {\"text\": {\"literalString\": \"Confirm Reservation\"}}\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>This defines the UI components for the surface: a text header, a date picker, and a button.</p>"},{"location":"quickstart/#populating-data","title":"Populating Data","text":"<pre><code>{\n  \"dataModelUpdate\": {\n    \"surfaceId\": \"main\",\n    \"contents\": [\n      {\n        \"key\": \"reservation\",\n        \"valueMap\": [\n          {\"key\": \"date\", \"valueString\": \"2025-12-15\"},\n          {\"key\": \"time\", \"valueString\": \"19:00\"},\n          {\"key\": \"guests\", \"valueInt\": 2}\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>This populates the data model that components can bind to.</p>"},{"location":"quickstart/#signaling-render","title":"Signaling Render","text":"<pre><code>{\"beginRendering\": {\"surfaceId\": \"main\", \"root\": \"header\"}}\n</code></pre> <p>This tells the client it has enough information to render the UI.</p> <p>It's Just JSON</p> <p>Notice how readable and structured this is? LLMs can generate this easily, and it's safe to transmit and render\u2014no code execution required.</p>"},{"location":"quickstart/#exploring-other-demos","title":"Exploring Other Demos","text":"<p>The repository includes several other demos:</p>"},{"location":"quickstart/#component-gallery-no-agent-required","title":"Component Gallery (No Agent Required)","text":"<p>See all available A2UI components:</p> <pre><code>npm start -- gallery\n</code></pre> <p>This runs a client-only demo showcasing every standard component (Card, Button, TextField, Timeline, etc.) with live examples and code samples.</p>"},{"location":"quickstart/#contact-lookup-demo","title":"Contact Lookup Demo","text":"<p>Try a different agent use case:</p> <pre><code>npm run demo:contact\n</code></pre> <p>This demonstrates a contact lookup agent that generates search forms and result lists.</p>"},{"location":"quickstart/#whats-next","title":"What's Next?","text":"<p>Now that you've seen A2UI in action, you're ready to:</p> <ul> <li>Learn Core Concepts: Understand surfaces, components, and data binding</li> <li>Set Up Your Own Client: Integrate A2UI into your own app</li> <li>Build an Agent: Create agents that generate A2UI responses</li> <li>Explore the Protocol: Dive into the technical specification</li> </ul>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quickstart/#port-already-in-use","title":"Port Already in Use","text":"<p>If port 5173 is already in use, the dev server will automatically try the next available port. Check the terminal output for the actual URL.</p>"},{"location":"quickstart/#api-key-issues","title":"API Key Issues","text":"<p>If you see errors about missing API keys:</p> <ol> <li>Verify the key is exported: <code>echo $GEMINI_API_KEY</code></li> <li>Make sure it's a valid Gemini API key from Google AI Studio</li> <li>Try re-exporting: <code>export GEMINI_API_KEY=\"your_key\"</code></li> </ol>"},{"location":"quickstart/#python-dependencies","title":"Python Dependencies","text":"<p>The demo uses Python for the A2A agent. If you encounter Python errors:</p> <pre><code># Make sure Python 3.10+ is installed\npython3 --version\n\n# The demo should auto-install dependencies via the npm script\n# If not, manually install them:\ncd ../../agent/adk/restaurant_finder\npip install -r requirements.txt\n</code></pre>"},{"location":"quickstart/#still-having-issues","title":"Still Having Issues?","text":"<ul> <li>Check the GitHub Issues</li> <li>Review the samples/client/lit/README.md</li> <li>Join the community discussions</li> </ul>"},{"location":"quickstart/#understanding-the-demo-code","title":"Understanding the Demo Code","text":"<p>Want to see how it works? Check out:</p> <ul> <li>Agent Code: <code>samples/agent/adk/restaurant_finder/</code> - The Python A2A agent</li> <li>Client Code: <code>samples/client/lit/</code> - The Lit web client with A2UI renderer</li> <li>A2UI Renderer: <code>web-lib/</code> - The web renderer implementation</li> </ul> <p>Each directory has its own README with detailed documentation.</p> <p>Congratulations! You've successfully run your first A2UI application. You've seen how an AI agent can generate rich, interactive UIs that render natively in a web application\u2014all through safe, declarative JSON messages.</p>"},{"location":"renderers/","title":"Renderers (Client Libraries)","text":"<p>Renderers convert A2UI JSON messages into native UI components for different platforms.</p> <p>The agents are responsible for generating the A2UI messages,  and the transports are responsible for delivering the messages to the client. The client renderer library must buffer and handle A2UI messages, implement the A2UI lifecycle, and render surfaces (widgets).</p> <p>You have a lot of flexibility, to bring custom comonents to a renderer, or build your own renderer to support your UI component framework.</p>"},{"location":"renderers/#available-renderers","title":"Available Renderers","text":"Renderer Platform Status Links Lit (Web Components) Web \u2705 Stable Code Angular Web \u2705 Stable Code Flutter (GenUI SDK) Mobile/Desktop/Web \u2705 Stable Docs \u00b7 Code React Web \ud83d\udea7 In Progress Coming Q1 2026 <p>Check the Roadmap for more.</p>"},{"location":"renderers/#how-renderers-work","title":"How Renderers Work","text":"<pre><code>A2UI JSON \u2192 Renderer \u2192 Native Components \u2192 Your App\n</code></pre> <ol> <li>Receive A2UI messages from the transport</li> <li>Parse the JSON and validate against the schema</li> <li>Render using platform-native components</li> <li>Style according to your app's theme</li> </ol>"},{"location":"renderers/#quick-start","title":"Quick Start","text":"<p>Web Components (Lit):</p> <pre><code>npm install @a2ui/lit\n</code></pre> <p>TODO: Add a quickstart guide</p> <p>Angular:</p> <pre><code>npm install @a2ui/angular\n</code></pre> <p>TODO: Add a quickstart guide</p> <p>Flutter:</p> <pre><code>flutter pub add flutter_genui\n</code></pre> <p>TODO: Add a quickstart guide</p>"},{"location":"renderers/#adding-custom-components-to-a-renderer","title":"Adding custom components to a renderer","text":"<p>TODO: Add a guide</p>"},{"location":"renderers/#theming-or-styling-a-renderer","title":"Theming or styling a renderer","text":"<p>TODO: Add a guide</p>"},{"location":"renderers/#building-a-renderer","title":"Building a Renderer","text":"<p>Want to build a renderer for your platform? </p> <ul> <li>See the Roadmap for planned frameworks.</li> <li>Review existing renderers for patterns.</li> </ul>"},{"location":"renderers/#key-requirements","title":"Key requirements:","text":"<ul> <li>Parse A2UI JSON messages, specifically the adjacency list format</li> <li>Map A2UI components to native widgets</li> <li>Handle data binding, lifecycle events</li> <li>Process a sequence of incremental A2UI messages to build and update the UI</li> <li>Support server initiated updates</li> <li>Support user actions</li> </ul>"},{"location":"renderers/#next-steps","title":"Next Steps","text":"<ul> <li>Client Setup Guide: Integration instructions</li> <li>Quickstart: Try the Lit renderer</li> <li>Component Reference: What components to support</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":"<p>This roadmap outlines the current state and future plans for the A2UI project. The project is under active development, and priorities may shift based on community feedback and emerging use cases.</p>"},{"location":"roadmap/#current-status","title":"Current Status","text":""},{"location":"roadmap/#protocol","title":"Protocol","text":"Version Status Notes v0.8 \u2705 Stable Initial public release v0.9 \ud83d\udea7 In Progress Draft specification improvements <p>Key features:</p> <ul> <li>\u2705 Streaming JSONL message format</li> <li>\u2705 Four core message types (<code>surfaceUpdate</code>, <code>dataModelUpdate</code>, <code>beginRendering</code>, <code>deleteSurface</code>)</li> <li>\u2705 Adjacency list component model</li> <li>\u2705 JSON Pointer-based data binding</li> <li>\u2705 Separation of structure and state</li> </ul>"},{"location":"roadmap/#renderers","title":"Renderers","text":"Client libraries Status Platform Notes Web Components (Lit) \u2705 Stable Web Framework-agnostic, works anywhere Angular \u2705 Stable Web Full Angular integration Flutter (GenUI SDK) \u2705 Stable Multi-platform Works on mobile, web, desktop React \ud83d\udea7 In Progress Web Coming Q1 2026 SwiftUI \ud83d\udccb Planned iOS/macOS Planned for Q2 2026 Jetpack Compose \ud83d\udccb Planned Android Planned for Q2 2026 Vue \ud83d\udca1 Proposed Web Community interest ShadCN (React) \ud83d\udca1 Proposed Web Community interest"},{"location":"roadmap/#transports","title":"Transports","text":"Transport Status Notes A2A Protocol \u2705 Complete Native A2A transport AG UI \u2705 Complete Day-zero compatibility REST API \ud83d\udccb Planned Bidirectional communication WebSockets \ud83d\udca1 Proposed Bidirectional communication SSE (Server-Sent Events) \ud83d\udca1 Proposed Web streaming MCP (Model Context Protocol) \ud83d\udca1 Proposed Community interest"},{"location":"roadmap/#agent-ui-toolkits","title":"Agent UI toolkits","text":"Agent UI toolkit Status Notes CopilotKit \u2705 Complete Day-zero compatibility thanks to AG UI Open AI ChatKit \ud83d\udca1 Proposed Community interest Vecel AI SDK UI \ud83d\udca1 Proposed Community interest"},{"location":"roadmap/#agent-frameworks","title":"Agent frameworks","text":"Integration Status Notes Any agent with A2A support \u2705 Complete Day-zero compatibility thanks to A2A protocol ADK \ud83d\udccb Planned Still designing developer ergonomics, see samples Genkit \ud83d\udca1 Proposed Community interest LangGraph \ud83d\udca1 Proposed Community interest CrewAI \ud83d\udca1 Proposed Community interest AG2 \ud83d\udca1 Proposed Community interest Claude Agent SDK \ud83d\udca1 Proposed Community interest OpenAI Agent SDK \ud83d\udca1 Proposed Community interest Microsoft Agent Framework \ud83d\udca1 Proposed Community interest AWS Strands Agent SDK \ud83d\udca1 Proposed Community interest"},{"location":"roadmap/#recent-milestones","title":"Recent Milestones","text":""},{"location":"roadmap/#q2-2025","title":"Q2 2025","text":"<p>Many research projects across multiple Google teams, including integration into internal products and agents.</p>"},{"location":"roadmap/#q4-2025","title":"Q4 2025","text":"<ul> <li>v0.8.0 spec released</li> <li>A2A extension (thanks Google A2A team! teased at a2asummit.ai)</li> <li>Flutter renderer (thanks Flutter team!)</li> <li>Angular renderer (thanks Angular team!)</li> <li>Web components (Lit) renderer (thanks Opal team &amp; friends!)</li> <li>AG UI / CopilotKit integration (thanks CopilotKit team!)</li> <li>Github public release (Apache 2.0)</li> </ul>"},{"location":"roadmap/#upcoming-milestones","title":"Upcoming Milestones","text":""},{"location":"roadmap/#q1-2026","title":"Q1 2026","text":""},{"location":"roadmap/#a2ui-v09","title":"A2UI v0.9","text":"<ul> <li>Release candidate for spec 0.9</li> <li>Improve theming support for renderers (complete)</li> <li>Improve server side theming support for agents (minimal)</li> <li>Improve developer ergonomics</li> </ul>"},{"location":"roadmap/#react-renderer","title":"React Renderer","text":"<p>A native React renderer with hooks-based API and full TypeScript support.</p> <ul> <li>React support for common widgets</li> <li>React support for custom components</li> <li><code>useA2UI</code> hook for message handling</li> <li>React support for theming</li> </ul>"},{"location":"roadmap/#q2-2026","title":"Q2 2026","text":""},{"location":"roadmap/#native-mobile-renderers","title":"Native Mobile Renderers","text":"<p>Native renderers for iOS and Android platforms.</p> <p>SwiftUI Renderer (iOS/macOS):</p> <ul> <li>Native SwiftUI components</li> <li>iOS design language support</li> <li>macOS compatibility</li> </ul> <p>Jetpack Compose Renderer (Android):</p> <ul> <li>Native Compose UI components</li> <li>Material Design 3 support</li> <li>Android platform integration</li> </ul>"},{"location":"roadmap/#performance-optimizations","title":"Performance Optimizations","text":"<ul> <li>Renderer performance benchmarks</li> <li>Lazy loading for large component trees</li> <li>Virtual scrolling for lists</li> <li>Component memoization strategies</li> </ul>"},{"location":"roadmap/#q4-2026","title":"Q4 2026","text":""},{"location":"roadmap/#protocol-v10","title":"Protocol v1.0","text":"<p>Finalize v1.0 of the protocol with:</p> <ul> <li>Stability guarantees</li> <li>Migration path from v0.9</li> <li>Comprehensive test suite</li> <li>Certification program for renderers</li> </ul>"},{"location":"roadmap/#long-term-vision","title":"Long-Term Vision","text":""},{"location":"roadmap/#multi-agent-coordination","title":"Multi-Agent Coordination","text":"<p>Enhanced support for multiple agents contributing to the same UI:</p> <ul> <li>Recommended agent composition patterns</li> <li>Conflict resolution strategies</li> <li>Shared surface management</li> </ul>"},{"location":"roadmap/#accessibility-features","title":"Accessibility Features","text":"<p>First-class accessibility support:</p> <ul> <li>ARIA attribute generation</li> <li>Screen reader optimization</li> <li>Keyboard navigation standards</li> <li>Contrast and color guidance</li> </ul>"},{"location":"roadmap/#advanced-ui-patterns","title":"Advanced UI Patterns","text":"<p>Support for more complex UI interactions:</p> <ul> <li>Drag and drop</li> <li>Gestures and animations</li> <li>3D rendering</li> <li>AR/VR interfaces (exploratory)</li> </ul>"},{"location":"roadmap/#ecosystem-growth","title":"Ecosystem Growth","text":"<ul> <li>More framework integrations</li> <li>Third-party component libraries</li> <li>Agent marketplace integration</li> <li>Enterprise features and support</li> </ul>"},{"location":"roadmap/#community-requests","title":"Community Requests","text":"<p>Features requested by the community (in no particular order):</p> <ul> <li>More renderer integrations: Map from your client library to A2UI</li> <li>More agent frameworks: Map from your agent framework to A2UI</li> <li>More transports: Map from your transport to A2UI</li> <li>Community component library: Share custom components with the community</li> <li>Community samples: Share custom samples with the community</li> <li>Community evaluations: Generative UI evaluation scenarios and labeled datasets</li> <li>Developer Ergonomics: If you can build a better A2UI experience, share it with the community</li> </ul>"},{"location":"roadmap/#how-to-influence-the-roadmap","title":"How to Influence the Roadmap","text":"<p>We welcome community input on priorities:</p> <ol> <li>Vote on Issues: Give \ud83d\udc4d to GitHub issues you care about</li> <li>Propose Features: Open a discussion on GitHub (search for existing discussions first)</li> <li>Submit PRs: Build the features you need (search for existing PRs first)</li> <li>Join Discussions: Share your use cases and requirements (search for existing discussions first)</li> </ol>"},{"location":"roadmap/#release-cycle","title":"Release Cycle","text":"<ul> <li>Major versions (1.0, 2.0): Annual or when significant breaking changes are needed</li> <li>Minor versions (1.1, 1.2): Quarterly with new features</li> <li>Patch versions (1.1.1, 1.1.2): As needed for bug fixes</li> </ul>"},{"location":"roadmap/#versioning-policy","title":"Versioning Policy","text":"<p>A2UI follows Semantic Versioning:</p> <ul> <li>MAJOR: Incompatible protocol changes</li> <li>MINOR: Backward-compatible functionality additions</li> <li>PATCH: Backward-compatible bug fixes</li> </ul>"},{"location":"roadmap/#get-involved","title":"Get Involved","text":"<p>Want to contribute to the roadmap?</p> <ul> <li>Propose features in GitHub Discussions</li> <li>Build prototypes and share them with the community</li> <li>Join the conversation on GitHub Issues</li> </ul>"},{"location":"roadmap/#stay-updated","title":"Stay Updated","text":"<ul> <li>Watch the GitHub repository for updates</li> <li>Star the repo to show your support</li> <li>Follow releases to get notified of new versions</li> </ul> <p>Last Updated: December 2025</p> <p>Have questions about the roadmap? Start a discussion on GitHub.</p>"},{"location":"transports/","title":"Transports (Message Passing)","text":"<p>Transports deliver A2UI messages from agents to clients. A2UI is transport-agnostic\u2014use any method that can send JSON.</p> <p>The actual component rendering is done by the renderer, and the agents are responsible for generating the A2UI messages. Getting the messages from the agent to the client is the job of the transport.</p>"},{"location":"transports/#how-it-works","title":"How It Works","text":"<pre><code>Agent \u2192 Transport \u2192 Client Renderer\n</code></pre> <p>A2UI defines a sequence of JSON messages. The transport layer is responsible for delivering this sequence from the agent to the client. A common transport mechanism is a stream using a format like JSON Lines (JSONL), where each line is a single A2UI message.</p>"},{"location":"transports/#available-transports","title":"Available Transports","text":"Transport Status Use Case A2A Protocol \u2705 Stable Multi-agent systems, enterprise meshes AG UI \u2705 Stable Full-stack React applications REST API \ud83d\udccb Planned Simple HTTP endpoints WebSockets \ud83d\udca1 Proposed Real-time bidirectional SSE (Server-Sent Events) \ud83d\udca1 Proposed Web streaming"},{"location":"transports/#a2a-protocol","title":"A2A Protocol","text":"<p>The Agent2Agent (A2A) protocol provides secure, standardized agent communication.  An A2A extension provides easy integration with A2UI.</p> <p>Benefits:</p> <ul> <li>Security and authentication built-in</li> <li>Bindings for many message formats, auth, and transport protocols</li> <li>Clean separation of concerns</li> </ul> <p>If you are using A2A, this should be nearly automatic.</p> <p>TODO: Add a detailed guide.</p> <p>See: A2A Extension Specification</p>"},{"location":"transports/#ag-ui","title":"AG UI","text":"<p>AG UI translates from A2UI messages to AG UI messages, and handles transport and state sync automatically.</p> <p>If you are using AG UI, this should be automatic.</p> <p>TODO: Add a detailed guide.</p>"},{"location":"transports/#custom-transports","title":"Custom Transports","text":"<p>You can use any transport that sends JSON:</p> <p>HTTP/REST:</p> <pre><code>// TODO: Add an example\n</code></pre> <p>WebSockets:</p> <pre><code>// TODO: Add an example\n</code></pre> <p>Server-Sent Events:</p> <pre><code>// TODO: Add an example\n</code></pre> <p>```</p>"},{"location":"transports/#next-steps","title":"Next Steps","text":"<ul> <li>A2A Protocol Docs: Learn about A2A</li> <li>A2A Extension Spec: A2UI + A2A details</li> </ul>"},{"location":"concepts/components/","title":"Components &amp; Structure","text":"<p>A2UI uses an adjacency list model for component hierarchies. Instead of nested JSON trees, components are a flat list with ID references.</p>"},{"location":"concepts/components/#why-flat-lists","title":"Why Flat Lists?","text":"<p>Traditional nested approach: - LLM must generate perfect nesting in one pass - Hard to update deeply nested components - Difficult to stream incrementally</p> <p>A2UI adjacency list: - \u2705 Flat structure, easy for LLMs to generate - \u2705 Send components incrementally - \u2705 Update any component by ID - \u2705 Clear separation of structure and data</p>"},{"location":"concepts/components/#the-adjacency-list-model","title":"The Adjacency List Model","text":"<pre><code>{\n  \"surfaceUpdate\": {\n    \"components\": [\n      {\"id\": \"root\", \"component\": {\"Column\": {\"children\": {\"explicitList\": [\"greeting\", \"buttons\"]}}}},\n      {\"id\": \"greeting\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Hello\"}}}},\n      {\"id\": \"buttons\", \"component\": {\"Row\": {\"children\": {\"explicitList\": [\"cancel-btn\", \"ok-btn\"]}}}},\n      {\"id\": \"cancel-btn\", \"component\": {\"Button\": {\"child\": \"cancel-text\", \"action\": {\"name\": \"cancel\"}}}},\n      {\"id\": \"cancel-text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Cancel\"}}}},\n      {\"id\": \"ok-btn\", \"component\": {\"Button\": {\"child\": \"ok-text\", \"action\": {\"name\": \"ok\"}}}},\n      {\"id\": \"ok-text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"OK\"}}}}\n    ]\n  }\n}\n</code></pre> <p>Components reference children by ID, not by nesting.</p>"},{"location":"concepts/components/#component-basics","title":"Component Basics","text":"<p>Every component has:</p> <ol> <li>ID: Unique identifier (<code>\"welcome-message\"</code>)</li> <li>Type: Component type (<code>Text</code>, <code>Button</code>, <code>Card</code>)</li> <li>Properties: Configuration specific to that type</li> </ol> <pre><code>{\"id\": \"welcome\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Hello\"}, \"usageHint\": \"h1\"}}}\n</code></pre>"},{"location":"concepts/components/#the-standard-catalog","title":"The Standard Catalog","text":"<p>A2UI defines a standard catalog of components organized by purpose:</p> <ul> <li>Layout: Row, Column, List - arrange other components</li> <li>Display: Text, Image, Icon, Video, Divider - show information</li> <li>Interactive: Button, TextField, CheckBox, DateTimeInput, Slider - user input</li> <li>Container: Card, Tabs, Modal - group and organize content</li> </ul> <p>For the complete component gallery with examples, see Component Reference.</p>"},{"location":"concepts/components/#static-vs-dynamic-children","title":"Static vs. Dynamic Children","text":"<p>Static (<code>explicitList</code>) - Fixed list of child IDs: <pre><code>{\"children\": {\"explicitList\": [\"back-btn\", \"title\", \"menu-btn\"]}}\n</code></pre></p> <p>Dynamic (<code>template</code>) - Generate children from data array: <pre><code>{\"children\": {\"template\": {\"dataBinding\": \"/items\", \"componentId\": \"item-template\"}}}\n</code></pre></p> <p>For each item in <code>/items</code>, render the <code>item-template</code>. See Data Binding for details.</p>"},{"location":"concepts/components/#hydrating-with-values","title":"Hydrating with Values","text":"<p>Components get their values two ways:</p> <p>Literal - Fixed value: <code>{\"text\": {\"literalString\": \"Welcome\"}}</code> Data-bound - From data model: <code>{\"text\": {\"path\": \"/user/name\"}}</code></p> <p>LLMs can generate components with literal values or bind them to data paths for dynamic content.</p>"},{"location":"concepts/components/#composing-surfaces","title":"Composing Surfaces","text":"<p>Components compose into surfaces (widgets):</p> <ol> <li>LLM generates component definitions via <code>surfaceUpdate</code></li> <li>LLM populates data via <code>dataModelUpdate</code></li> <li>LLM signals render via <code>beginRendering</code></li> <li>Client renders all components as native widgets</li> </ol> <p>A surface is a complete, cohesive UI (form, dashboard, chat, etc.).</p>"},{"location":"concepts/components/#incremental-updates","title":"Incremental Updates","text":"<p>Add - Send new <code>surfaceUpdate</code> with new component IDs Update - Send <code>surfaceUpdate</code> with existing ID and new properties Remove - Update parent's <code>children</code> list to exclude removed IDs</p> <p>The flat structure makes all updates simple ID-based operations.</p>"},{"location":"concepts/components/#custom-components","title":"Custom Components","text":"<p>Beyond the standard catalog, clients can define custom components for domain-specific needs:</p> <ul> <li>How: Register custom component types in your renderer</li> <li>What: Charts, maps, custom visualizations, specialized widgets</li> <li>Security: Custom components still part of the client's trusted catalog</li> </ul> <p>Custom components are advertised from the client's renderer to the LLM. The LLM can then use them in addition to the standard catalog.</p> <p>See Custom Components Guide for implementation details.</p>"},{"location":"concepts/components/#best-practices","title":"Best Practices","text":"<ol> <li>Descriptive IDs: Use <code>\"user-profile-card\"</code> not <code>\"c1\"</code></li> <li>Shallow hierarchies: Avoid deep nesting</li> <li>Separate structure from content: Use data bindings, not literals</li> <li>Reuse with templates: One template, many instances via dynamic children</li> </ol>"},{"location":"concepts/data-binding/","title":"Data Binding","text":"<p>Data binding connects UI components to application state using JSON Pointer paths (RFC 6901). It's what allows A2UI to efficiently define layouts for large arrays of data, or to show updated content without being regenerated from scratch.</p>"},{"location":"concepts/data-binding/#structure-vs-state","title":"Structure vs. State","text":"<p>A2UI separates:</p> <ol> <li>UI Structure (Components): What the interface looks like</li> <li>Application State (Data Model): What data it displays</li> </ol> <p>This enables: reactive updates, data-driven UIs, reusable templates, and bidirectional binding.</p>"},{"location":"concepts/data-binding/#the-data-model","title":"The Data Model","text":"<p>Each surface has a JSON object holding state:</p> <pre><code>{\n  \"user\": {\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n  \"cart\": {\n    \"items\": [{\"name\": \"Widget\", \"price\": 9.99, \"quantity\": 2}],\n    \"total\": 19.98\n  }\n}\n</code></pre>"},{"location":"concepts/data-binding/#json-pointer-paths","title":"JSON Pointer Paths","text":"<p>Syntax:</p> <ul> <li><code>/user/name</code> - Object property</li> <li><code>/cart/items/0</code> - Array index (zero-based)</li> <li><code>/cart/items/0/price</code> - Nested path</li> </ul> <p>Example:</p> <pre><code>{\"user\": {\"name\": \"Alice\"}, \"items\": [\"Apple\", \"Banana\"]}\n</code></pre> <ul> <li><code>/user/name</code> \u2192 <code>\"Alice\"</code></li> <li><code>/items/0</code> \u2192 <code>\"Apple\"</code></li> </ul>"},{"location":"concepts/data-binding/#literal-vs-path-values","title":"Literal vs. Path Values","text":"<p>Literal (fixed): <pre><code>{\"id\": \"title\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Welcome\"}}}}\n</code></pre></p> <p>Data-bound (reactive): <pre><code>{\"id\": \"username\", \"component\": {\"Text\": {\"text\": {\"path\": \"/user/name\"}}}}\n</code></pre></p> <p>When <code>/user/name</code> changes from \"Alice\" to \"Bob\", the text automatically updates to \"Bob\".</p>"},{"location":"concepts/data-binding/#reactive-updates","title":"Reactive Updates","text":"<p>Components bound to data paths automatically update when the data changes:</p> <pre><code>{\"id\": \"status\", \"component\": {\"Text\": {\"text\": {\"path\": \"/order/status\"}}}}\n</code></pre> <p>Initial: <code>/order/status</code> = \"Processing...\" \u2192 displays \"Processing...\" Update: Send <code>dataModelUpdate</code> with <code>status: \"Shipped\"</code> \u2192 displays \"Shipped\"</p> <p>No component updates needed\u2014just data updates.</p>"},{"location":"concepts/data-binding/#dynamic-lists","title":"Dynamic Lists","text":"<p>Use templates to render arrays:</p> <pre><code>{\n  \"id\": \"product-list\",\n  \"component\": {\n    \"Column\": {\n      \"children\": {\"template\": {\"dataBinding\": \"/products\", \"componentId\": \"product-card\"}}\n    }\n  }\n}\n</code></pre> <p>Data: <pre><code>{\"products\": [{\"name\": \"Widget\", \"price\": 9.99}, {\"name\": \"Gadget\", \"price\": 19.99}]}\n</code></pre></p> <p>Result: Two cards rendered, one per product.</p>"},{"location":"concepts/data-binding/#scoped-paths","title":"Scoped Paths","text":"<p>Inside a template, paths are scoped to the array item:</p> <pre><code>{\"id\": \"product-name\", \"component\": {\"Text\": {\"text\": {\"path\": \"/name\"}}}}\n</code></pre> <p>For <code>/products/0</code>, <code>/name</code> resolves to <code>/products/0/name</code> \u2192 \"Widget\" For <code>/products/1</code>, <code>/name</code> resolves to <code>/products/1/name</code> \u2192 \"Gadget\"</p> <p>Adding/removing items automatically updates the rendered components.</p>"},{"location":"concepts/data-binding/#input-bindings","title":"Input Bindings","text":"<p>Interactive components update the data model bidirectionally:</p> Component Example User Action Data Update TextField <code>{\"text\": {\"path\": \"/form/name\"}}</code> Types \"Alice\" <code>/form/name</code> = \"Alice\" CheckBox <code>{\"value\": {\"path\": \"/form/agreed\"}}</code> Checks box <code>/form/agreed</code> = true MultipleChoice <code>{\"selections\": {\"path\": \"/form/country\"}}</code> Selects \"Canada\" <code>/form/country</code> = [\"ca\"]"},{"location":"concepts/data-binding/#best-practices","title":"Best Practices","text":"<p>1. Use granular updates - Update only changed paths: <pre><code>{\"dataModelUpdate\": {\"path\": \"/user\", \"contents\": [{\"key\": \"name\", \"valueString\": \"Alice\"}]}}\n</code></pre></p> <p>2. Organize by domain - Group related data: <pre><code>{\"user\": {...}, \"cart\": {...}, \"ui\": {...}}\n</code></pre></p> <p>3. Pre-compute display values - Agent formats data (currency, dates) before sending: <pre><code>{\"price\": \"$19.99\"}  // Not: {\"price\": 19.99}\n</code></pre></p>"},{"location":"concepts/data-flow/","title":"Data Flow","text":"<p>How messages flow from agents to UI.</p>"},{"location":"concepts/data-flow/#architecture","title":"Architecture","text":"<pre><code>Agent (LLM) \u2192 A2UI Generator \u2192 Transport (SSE/WS/A2A)\n                                      \u2193\nClient (Stream Reader) \u2192 Message Parser \u2192 Renderer \u2192 Native UI\n</code></pre>"},{"location":"concepts/data-flow/#message-format","title":"Message Format","text":"<p>A2UI defines a sequence of JSON messages that describe the UI. When streamed, these messages are often formatted as JSON Lines (JSONL), where each line is a complete JSON object.</p> <pre><code>{\"surfaceUpdate\":{\"surfaceId\":\"main\",\"components\":[...]}}\n{\"dataModelUpdate\":{\"surfaceId\":\"main\",\"contents\":[{\"key\":\"user\",\"valueMap\":[{\"key\":\"name\",\"valueString\":\"Alice\"}]}]}}\n{\"beginRendering\":{\"surfaceId\":\"main\",\"root\":\"root-component\"}}\n</code></pre> <p>Why this format? A sequence of self-contained JSON objects is streaming-friendly, easy for LLMs to generate incrementally, and resilient to errors.</p>"},{"location":"concepts/data-flow/#lifecycle-example-restaurant-booking","title":"Lifecycle Example: Restaurant Booking","text":"<p>User: \"Book a table for 2 tomorrow at 7pm\"</p> <p>1. Agent defines UI structure:</p> <pre><code>{\"surfaceUpdate\": {\"surfaceId\": \"booking\", \"components\": [\n  {\"id\": \"root\", \"component\": {\"Column\": {\"children\": {\"explicitList\": [\"header\", \"guests-field\", \"submit-btn\"]}}}},\n  {\"id\": \"header\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Confirm Reservation\"}, \"usageHint\": \"h1\"}}},\n  {\"id\": \"guests-field\", \"component\": {\"TextField\": {\"label\": {\"literalString\": \"Guests\"}, \"text\": {\"path\": \"/reservation/guests\"}}}},\n  {\"id\": \"submit-btn\", \"component\": {\"Button\": {\"child\": \"submit-text\", \"action\": {\"name\": \"confirm\", \"context\": [{\"key\": \"details\", \"value\": {\"path\": \"/reservation\"}}]}}}}\n]}}\n</code></pre> <p>2. Agent populates data:</p> <pre><code>{\"dataModelUpdate\": {\"surfaceId\": \"booking\", \"path\": \"/reservation\", \"contents\": [\n  {\"key\": \"datetime\", \"valueString\": \"2025-12-16T19:00:00Z\"},\n  {\"key\": \"guests\", \"valueString\": \"2\"}\n]}}\n</code></pre> <p>3. Agent signals render:</p> <pre><code>{\"beginRendering\": {\"surfaceId\": \"booking\", \"root\": \"root\"}}\n</code></pre> <p>4. User edits guests to \"3\" \u2192 Client updates <code>/reservation/guests</code> automatically (no message to agent yet)</p> <p>5. User clicks \"Confirm\" \u2192 Client sends action with updated data:</p> <pre><code>{\"userAction\": {\"name\": \"confirm\", \"surfaceId\": \"booking\", \"context\": {\"details\": {\"datetime\": \"2025-12-16T19:00:00Z\", \"guests\": \"3\"}}}}\n</code></pre> <p>6. Agent responds \u2192 Updates UI or sends <code>{\"deleteSurface\": {\"surfaceId\": \"booking\"}}</code> to clean up</p>"},{"location":"concepts/data-flow/#transport-options","title":"Transport Options","text":"<ul> <li>A2A Protocol: Multi-agent systems, can also be used for agent to UI communication</li> <li>AG UI: Bidirectional, real-time</li> <li>... others</li> </ul> <p>See transports for more details.</p>"},{"location":"concepts/data-flow/#progressive-rendering","title":"Progressive Rendering","text":"<p>Instead of waiting for the entire response to be generated before showing anything to the user, chunks of the response can be streamed to the client as they are generated and progressively rendered.</p> <p>Users see UI building in real-time instead of staring at a spinner.</p>"},{"location":"concepts/data-flow/#error-handling","title":"Error Handling","text":"<p>Malformed messages: Skip and continue, or send error back to agent for correction Network interruptions: Display error state, reconnect, agent resends or resumes</p>"},{"location":"concepts/data-flow/#performance","title":"Performance","text":"<p>Batching: Buffer updates for 16ms, batch render together Diffing: Compare old/new components, update only changed properties Granular updates: Update <code>/user/name</code> not entire <code>/</code> model</p>"},{"location":"concepts/overview/","title":"Core Concepts","text":"<p>This section explains the fundamental architecture of A2UI. Understanding these concepts will help you build effective agent-driven interfaces.</p>"},{"location":"concepts/overview/#the-big-picture","title":"The Big Picture","text":"<p>A2UI is built around three core ideas:</p> <ol> <li>Streaming Messages: UI updates flow as a sequence of JSON messages from agent to client</li> <li>Declarative Components: UIs are described as data, not programmed as code</li> <li>Data Binding: UI structure is separate from application state, enabling reactive updates</li> </ol>"},{"location":"concepts/overview/#key-topics","title":"Key Topics","text":""},{"location":"concepts/overview/#data-flow","title":"Data Flow","text":"<p>How messages travel from agents to rendered UI. Includes a complete lifecycle example of a restaurant booking flow, transport options (SSE, WebSockets, A2A), progressive rendering, and error handling.</p>"},{"location":"concepts/overview/#component-structure","title":"Component Structure","text":"<p>A2UI's adjacency list model for representing component hierarchies. Learn why flat lists are better than nested trees, how to use static vs. dynamic children, and best practices for incremental updates.</p>"},{"location":"concepts/overview/#data-binding","title":"Data Binding","text":"<p>How components connect to application state using JSON Pointer paths. Covers reactive components, dynamic lists, input bindings, and the separation of structure from state that makes A2UI powerful.</p>"},{"location":"concepts/overview/#message-types","title":"Message Types","text":"<p>A2UI uses four message types:</p> <ul> <li><code>surfaceUpdate</code>: Define or update UI components</li> <li><code>dataModelUpdate</code>: Update application state</li> <li><code>beginRendering</code>: Signal the client to render</li> <li><code>deleteSurface</code>: Remove a UI surface</li> </ul> <p>For complete technical details, see Message Reference.</p>"},{"location":"guides/agent-development/","title":"Agent Development Guide","text":"<p>Build AI agents that generate A2UI interfaces. This guide covers generating and streaming UI messages from LLMs.</p>"},{"location":"guides/agent-development/#quick-overview","title":"Quick Overview","text":"<p>Building an A2UI agent:</p> <ol> <li>Understand user intent \u2192 Decide what UI to show</li> <li>Generate A2UI JSON \u2192 Use LLM structured output or prompts</li> <li>Validate &amp; stream \u2192 Check schema, send to client</li> <li>Handle actions \u2192 Respond to user interactions</li> </ol>"},{"location":"guides/agent-development/#start-with-a-simple-agent","title":"Start with a simple agent","text":"<p>We will use the ADK to build a simple agent.  We will start with text and eventually upgrade it to A2UI.</p> <p>See step by step instructions at the ADK quickstart.</p> <pre><code>pip install google-adk\nadk create my_agent\n</code></pre> <p>Then edit the <code>my_agent/agent.py</code> file with a very simple agent for restaurant recommendations.</p> <pre><code>import json\nfrom google.adk.agents.llm_agent import Agent\nfrom google.adk.tools.tool_context import ToolContext\n\ndef get_restaurants(tool_context: ToolContext) -&gt; str:\n    \"\"\"Call this tool to get a list of restaurants.\"\"\"\n    return json.dumps([\n        {\n            \"name\": \"Xi'an Famous Foods\",\n            \"detail\": \"Spicy and savory hand-pulled noodles.\",\n            \"imageUrl\": \"http://localhost:10002/static/shrimpchowmein.jpeg\",\n            \"rating\": \"\u2605\u2605\u2605\u2605\u2606\",\n            \"infoLink\": \"[More Info](https://www.xianfoods.com/)\",\n            \"address\": \"81 St Marks Pl, New York, NY 10003\"\n        },\n        {\n            \"name\": \"Han Dynasty\",\n            \"detail\": \"Authentic Szechuan cuisine.\",\n            \"imageUrl\": \"http://localhost:10002/static/mapotofu.jpeg\",\n            \"rating\": \"\u2605\u2605\u2605\u2605\u2606\",\n            \"infoLink\": \"[More Info](https://www.handynasty.net/)\",\n            \"address\": \"90 3rd Ave, New York, NY 10003\"\n        },\n        {\n            \"name\": \"RedFarm\",\n            \"detail\": \"Modern Chinese with a farm-to-table approach.\",\n            \"imageUrl\": \"http://localhost:10002/static/beefbroccoli.jpeg\",\n            \"rating\": \"\u2605\u2605\u2605\u2605\u2606\",\n            \"infoLink\": \"[More Info](https://www.redfarmnyc.com/)\",\n            \"address\": \"529 Hudson St, New York, NY 10014\"\n        },\n    ])\n\nAGENT_INSTRUCTION=\"\"\"\nYou are a helpful restaurant finding assistant. Your goal is to help users find and book restaurants using a rich UI.\n\nTo achieve this, you MUST follow this logic:\n\n1.  **For finding restaurants:**\n    a. You MUST call the `get_restaurants` tool. Extract the cuisine, location, and a specific number (`count`) of restaurants from the user's query (e.g., for \"top 5 chinese places\", count is 5).\n    b. After receiving the data, you MUST follow the instructions precisely to generate the final a2ui UI JSON, using the appropriate UI example from the `prompt_builder.py` based on the number of restaurants.\"\"\"\n\nroot_agent = Agent(\n    model='gemini-2.5-flash',\n    name=\"restaurant_agent\",\n    description=\"An agent that finds restaurants and helps book tables.\",\n    instruction=AGENT_INSTRUCTION,\n    tools=[get_restaurants],\n)\n</code></pre> <p>Don't forget to set the <code>GOOGLE_API_KEY</code> environment variable to run this example.  </p> <pre><code>echo 'GOOGLE_API_KEY=\"YOUR_API_KEY\"' &gt; .env\n</code></pre> <p>You can test out this agent with the ADK web interface:</p> <pre><code>adk web\n</code></pre> <p>Select <code>my_agent</code> from the list, and ask questions about restaurants in new york.  You should see a list of restaurants in the UI as plain text.</p>"},{"location":"guides/agent-development/#generating-a2ui-messages","title":"Generating A2UI Messages","text":"<p>Getting the LLM to generate A2UI messages requires some prompt engineering.  </p> <p>Attention</p> <p>This is an area we are still designing.  The developer ergonomics of this are not yet finalized.</p> <p>For now, let's copy the <code>a2ui_schema.py</code> from the contact lookup example.  This is the easiest way to get the A2UI schema and examples for your agent (subject to change).</p> <pre><code>cp samples/agent/adk/contact_lookup/a2ui_schema.py my_agent/\n</code></pre> <p>First lets add the new imports to the <code>agent.py</code> file:</p> <pre><code># The schema for any A2UI message.  This never changes.\nfrom .a2ui_schema import A2UI_SCHEMA\n</code></pre> <p>Now we will modify the agent instructions to generate A2UI messages instead of plain text.  We will leave a placeholder for future UI examples.</p> <pre><code># Eventually you can copy &amp; paste some UI examples here, for few-shot in context learning\nRESTAURANT_UI_EXAMPLES = \"\"\"\n\"\"\"\n\n# Construct the full prompt with UI instructions, examples, and schema\nA2UI_AND_AGENT_INSTRUCTION = AGENT_INSTRUCTION + f\"\"\"\n\nYour final output MUST be a a2ui UI JSON response.\n\nTo generate the response, you MUST follow these rules:\n1.  Your response MUST be in two parts, separated by the delimiter: `---a2ui_JSON---`.\n2.  The first part is your conversational text response.\n3.  The second part is a single, raw JSON object which is a list of A2UI messages.\n4.  The JSON part MUST validate against the A2UI JSON SCHEMA provided below.\n\n--- UI TEMPLATE RULES ---\n-   If the query is for a list of restaurants, use the restaurant data you have already received from the `get_restaurants` tool to populate the `dataModelUpdate.contents` array (e.g., as a `valueMap` for the \"items\" key).\n-   If the number of restaurants is 5 or fewer, you MUST use the `SINGLE_COLUMN_LIST_EXAMPLE` template.\n-   If the number of restaurants is more than 5, you MUST use the `TWO_COLUMN_LIST_EXAMPLE` template.\n-   If the query is to book a restaurant (e.g., \"USER_WANTS_TO_BOOK...\"), you MUST use the `BOOKING_FORM_EXAMPLE` template.\n-   If the query is a booking submission (e.g., \"User submitted a booking...\"), you MUST use the `CONFIRMATION_EXAMPLE` template.\n\n{RESTAURANT_UI_EXAMPLES}\n\n---BEGIN A2UI JSON SCHEMA---\n{A2UI_SCHEMA}\n---END A2UI JSON SCHEMA---\n\"\"\"\n\nroot_agent = Agent(\n    model='gemini-2.5-flash',\n    name=\"restaurant_agent\",\n    description=\"An agent that finds restaurants and helps book tables.\",\n    instruction=A2UI_AND_AGENT_INSTRUCTION,\n    tools=[get_restaurants],\n)\n</code></pre>"},{"location":"guides/agent-development/#understanding-the-output","title":"Understanding the Output","text":"<p>Your agent will no longer strictly output text. Instead, it will output text and a JSON list of A2UI messages.</p> <p>The <code>A2UI_SCHEMA</code> that we imported is a standard JSON schema that defines valid operations like:</p> <ul> <li><code>render</code> (displaying a UI)</li> <li><code>update</code> (changing data in an existing UI)</li> </ul> <p>Because the output is structured JSON, you may parse and validate it before sending it to the client.</p> <pre><code># 1. Parse the JSON\n# Warning: Parsing the output as JSON is a fragile implementation useful for documentation.\n# LLMs often put Markdown fences around JSON output, and can make other mistakes.\n# Rely on frameworks to parse the JSON for you.\nparsed_json_data = json.loads(json_string_cleaned)\n\n# 2. Validate against A2UI_SCHEMA\n# This ensures the LLM generated valid A2UI commands\njsonschema.validate(\n    instance=parsed_json_data, schema=self.a2ui_schema_object\n)\n</code></pre> <p>By validating the output against <code>A2UI_SCHEMA</code>, you ensure that your client never receives malformed UI instructions.</p> <p>TODO: Continue this guide with examples of how to parse, validate, and send the output to the client renderer   without the A2A extension.</p>"},{"location":"guides/client-setup/","title":"Client Setup Guide","text":"<p>Integrate A2UI into your application using the renderer for your platform.</p>"},{"location":"guides/client-setup/#renderers","title":"Renderers","text":"Renderer Platform Status Lit (Web Components) Web \u2705 Stable Angular Web \u2705 Stable Flutter (GenUI SDK) Mobile/Desktop/Web \u2705 Stable React Web \ud83d\udea7 Coming Q1 2026 SwiftUI iOS/macOS \ud83d\udea7 Planned Q2 2026 Jetpack Compose Android \ud83d\udea7 Planned Q2 2026"},{"location":"guides/client-setup/#web-components-lit","title":"Web Components (Lit)","text":"<p>Attention</p> <p>The Lit client library is not yet published to NPM. Check back in the coming days.</p> <pre><code>npm install @a2ui/web-lib lit @lit-labs/signals\n</code></pre> <p>The Lit renderer uses:</p> <ul> <li>Message Processor: Manages A2UI state and processes incoming messages</li> <li><code>&lt;a2ui-surface&gt;</code> component: Renders surfaces in your app</li> <li>Lit Signals: Provides reactive state management for automatic UI updates</li> </ul> <p>TODO: Add verified setup example.</p> <p>See working example: Lit shell sample</p>"},{"location":"guides/client-setup/#angular","title":"Angular","text":"<p>Attention</p> <p>The Angular client library is not yet published to NPM. Check back in the coming days.</p> <pre><code>npm install @a2ui/angular @a2ui/web-lib\n</code></pre> <p>The Angular renderer provides:</p> <ul> <li><code>provideA2UI()</code> function: Configures A2UI in your app config</li> <li><code>Surface</code> component: Renders A2UI surfaces</li> <li><code>MessageProcessor</code> service: Handles incoming A2UI messages</li> </ul> <p>TODO: Add verified setup example.</p> <p>See working example: Angular restaurant sample</p>"},{"location":"guides/client-setup/#flutter-genui-sdk","title":"Flutter (GenUI SDK)","text":"<pre><code>flutter pub add flutter_genui\n</code></pre> <p>Flutter uses the GenUI SDK which provides native A2UI rendering.</p> <p>Docs: GenUI SDK | GitHub | README in GenUI Flutter Package</p>"},{"location":"guides/client-setup/#connecting-to-agents","title":"Connecting to Agents","text":"<p>Your client application needs to: 1. Receive A2UI messages from the agent (via transport) 2. Process messages using the Message Processor 3. Send user actions back to the agent</p> <p>Common transport options: - Server-Sent Events (SSE): One-way streaming from server to client - WebSockets: Bidirectional real-time communication - A2A Protocol: Standardized agent-to-agent communication with A2UI support</p> <p>TODO: Add transport implementation examples.</p> <p>See: Transports guide</p>"},{"location":"guides/client-setup/#handling-user-actions","title":"Handling User Actions","text":"<p>When users interact with A2UI components (clicking buttons, submitting forms, etc.), the client: 1. Captures the action event from the component 2. Resolves any data context needed for the action 3. Sends the action to the agent 4. Processes the agent's response messages</p> <p>TODO: Add action handling examples.</p>"},{"location":"guides/client-setup/#error-handling","title":"Error Handling","text":"<p>Common errors to handle: - Invalid Surface ID: Surface referenced before <code>beginRendering</code> was received - Invalid Component ID: Component IDs must be unique within a surface - Invalid Data Path: Check data model structure and JSON Pointer syntax - Schema Validation Failed: Verify message format matches A2UI specification</p> <p>TODO: Add error handling examples.</p>"},{"location":"guides/client-setup/#next-steps","title":"Next Steps","text":"<ul> <li>Quickstart: Try the demo application</li> <li>Theming &amp; Styling: Customize the look and feel</li> <li>Custom Components: Extend the component catalog</li> <li>Agent Development: Build agents that generate A2UI</li> <li>Reference Documentation: Deep dive into the protocol</li> </ul>"},{"location":"guides/custom-components/","title":"Custom Component Catalogs","text":"<p>Extend A2UI by defining custom catalogs that include your own components alongside standard A2UI components.</p>"},{"location":"guides/custom-components/#why-custom-catalogs","title":"Why Custom Catalogs?","text":"<p>The A2UI Standard Catalog provides common UI elements (buttons, text fields, etc.), but your application might need specialized components:</p> <ul> <li>Domain-specific widgets: Stock tickers, medical charts, CAD viewers</li> <li>Third-party integrations: Google Maps, payment forms, chat widgets</li> <li>Brand-specific components: Custom date pickers, product cards, dashboards</li> </ul> <p>Custom catalogs are collections of components that can include: - Standard A2UI components (Text, Button, TextField, etc.) - Your custom components (GoogleMap, StockTicker, etc.) - Third-party components</p> <p>You register entire catalogs with your client application, not individual components. This allows agents and clients to agree on a shared, extended set of components while maintaining security and type safety.</p>"},{"location":"guides/custom-components/#how-custom-catalogs-work","title":"How Custom Catalogs Work","text":"<ol> <li>Client Defines Catalog: You create a catalog definition that lists both standard and custom components.</li> <li>Client Registers Catalog: You register the catalog (and its component implementations) with your client app.</li> <li>Client Announces Support: The client informs the agent which catalogs it supports.</li> <li>Agent Selects Catalog: The agent chooses a catalog for a given UI surface.</li> <li>Agent Generates UI: The agent generates <code>surfaceUpdate</code> messages using components from that catalog by name.</li> </ol>"},{"location":"guides/custom-components/#defining-custom-catalogs","title":"Defining Custom Catalogs","text":"<p>TODO: Add detailed guide for defining custom catalogs for each platform.</p> <p>Web (Lit / Angular): - How to define a catalog with both standard and custom components - How to register the catalog with the A2UI client - How to implement custom component classes</p> <p>Flutter: - How to define custom catalogs using GenUI - How to register custom component renderers</p> <p>See working examples: - Lit samples - Angular samples - Flutter GenUI docs</p>"},{"location":"guides/custom-components/#agent-side-using-components-from-a-custom-catalog","title":"Agent-Side: Using Components from a Custom Catalog","text":"<p>Once a catalog is registered on the client, agents can use components from it in <code>surfaceUpdate</code> messages.</p> <p>The agent specifies which catalog to use via the <code>catalogId</code> in the <code>beginRendering</code> message.</p> <p>TODO: Add examples of: - How agents select catalogs - How agents reference custom components from catalogs - How catalog versioning works</p>"},{"location":"guides/custom-components/#data-binding-and-actions","title":"Data Binding and Actions","text":"<p>Custom components support the same data binding and action mechanisms as standard components:</p> <ul> <li>Data binding: Custom components can bind properties to data model paths using JSON Pointer syntax</li> <li>Actions: Custom components can emit actions that the agent receives and handles</li> </ul>"},{"location":"guides/custom-components/#security-considerations","title":"Security Considerations","text":"<p>When creating custom catalogs and components:</p> <ol> <li>Allowlist components: Only register components you trust in your catalogs</li> <li>Validate properties: Always validate component properties from agent messages</li> <li>Sanitize user input: If components accept user input, sanitize it before processing</li> <li>Limit API access: Don't expose sensitive APIs or credentials to custom components</li> </ol> <p>TODO: Add detailed security best practices and code examples.</p>"},{"location":"guides/custom-components/#next-steps","title":"Next Steps","text":"<ul> <li>Theming &amp; Styling: Customize the look and feel of components</li> <li>Component Reference: See all standard components</li> <li>Agent Development: Build agents that use custom components</li> </ul>"},{"location":"guides/theming/","title":"Theming &amp; Styling","text":"<p>Customize the look and feel of A2UI components to match your brand.</p>"},{"location":"guides/theming/#the-a2ui-styling-philosophy","title":"The A2UI Styling Philosophy","text":"<p>A2UI follows a client-controlled styling approach:</p> <ul> <li>Agents describe what to show (components and structure)</li> <li>Clients decide how it looks (colors, fonts, spacing)</li> </ul> <p>This ensures:</p> <ul> <li>\u2705 Brand consistency: All UIs match your app's design system</li> <li>\u2705 Security: Agents can't inject arbitrary CSS or styling</li> <li>\u2705 Accessibility: You control contrast, focus states, and ARIA attributes</li> <li>\u2705 Platform-native feel: Web apps look like web, mobile looks like mobile</li> </ul>"},{"location":"guides/theming/#styling-layers","title":"Styling Layers","text":"<p>A2UI styling works in layers:</p> flowchart TD     A[\"1. Semantic HintsAgent provides hints(e.g., usageHint: 'h1')\"]     B[\"2. Theme ConfigurationYou configure(colors, fonts, spacing)\"]     C[\"3. Component OverridesYou customize(CSS/styles for specific components)\"]     D[\"4. Rendered OutputNative platform widgets\"]      A --&gt; B --&gt; C --&gt; D"},{"location":"guides/theming/#layer-1-semantic-hints","title":"Layer 1: Semantic Hints","text":"<p>Agents provide semantic hints (not visual styles) to guide client rendering:</p> <pre><code>{\n  \"id\": \"title\",\n  \"component\": {\n    \"Text\": {\n      \"text\": {\"literalString\": \"Welcome\"},\n      \"usageHint\": \"h1\"\n    }\n  }\n}\n</code></pre> <p>Common <code>usageHint</code> values: - Text: <code>h1</code>, <code>h2</code>, <code>h3</code>, <code>h4</code>, <code>h5</code>, <code>body</code>, <code>caption</code> - Other components have their own hints (see Component Reference)</p> <p>The client renderer maps these semantic hints to actual visual styles based on your theme and design system.</p>"},{"location":"guides/theming/#layer-2-theme-configuration","title":"Layer 2: Theme Configuration","text":"<p>Each renderer provides a way to configure your design system globally, including:</p> <ul> <li>Colors: Primary, secondary, background, surface, error, success, etc.</li> <li>Typography: Font families, sizes, weights, line heights</li> <li>Spacing: Base units and scale (xs, sm, md, lg, xl)</li> <li>Shapes: Border radius values</li> <li>Elevation: Shadow styles for depth</li> </ul> <p>TODO: Add platform-specific theming guides:</p> <p>Web (Lit): - How to configure theme via renderer initialization - Available theme properties</p> <p>Angular: - Integration with Angular Material theming - Standalone A2UI theme configuration</p> <p>Flutter: - How A2UI uses Flutter's <code>ThemeData</code> - Custom theme properties</p> <p>See working examples: - Lit samples - Angular samples - Flutter GenUI docs</p>"},{"location":"guides/theming/#layer-3-component-overrides","title":"Layer 3: Component Overrides","text":"<p>Beyond global theming, you can override styles for specific components:</p> <p>Web renderers: - CSS custom properties (CSS variables) for fine-grained control - Standard CSS selectors for component-specific overrides</p> <p>Flutter: - Widget-specific theme overrides via <code>ThemeData</code></p> <p>TODO: Add detailed component override examples for each platform.</p>"},{"location":"guides/theming/#common-styling-features","title":"Common Styling Features","text":""},{"location":"guides/theming/#dark-mode","title":"Dark Mode","text":"<p>A2UI renderers typically support automatic dark mode based on system preferences:</p> <ul> <li>Auto-detect system theme (<code>prefers-color-scheme</code>)</li> <li>Manual light/dark theme selection</li> <li>Custom dark theme configuration</li> </ul> <p>TODO: Add dark mode configuration examples.</p>"},{"location":"guides/theming/#responsive-design","title":"Responsive Design","text":"<p>A2UI components are responsive by default. You can further customize responsive behavior:</p> <ul> <li>Media queries for different screen sizes</li> <li>Container queries for component-level responsiveness</li> <li>Responsive spacing and typography scales</li> </ul> <p>TODO: Add responsive design examples.</p>"},{"location":"guides/theming/#custom-fonts","title":"Custom Fonts","text":"<p>Load and use custom fonts in your A2UI application:</p> <ul> <li>Web fonts (Google Fonts, etc.)</li> <li>Self-hosted fonts</li> <li>Platform-specific font loading</li> </ul> <p>TODO: Add custom font examples.</p>"},{"location":"guides/theming/#best-practices","title":"Best Practices","text":""},{"location":"guides/theming/#1-use-semantic-hints-not-visual-properties","title":"1. Use Semantic Hints, Not Visual Properties","text":"<p>Agents should provide semantic hints (<code>usageHint</code>), never visual styles:</p> <pre><code>// \u2705 Good: Semantic hint\n{\n  \"component\": {\n    \"Text\": {\n      \"text\": {\"literalString\": \"Welcome\"},\n      \"usageHint\": \"h1\"\n    }\n  }\n}\n\n// \u274c Bad: Visual properties (not supported)\n{\n  \"component\": {\n    \"Text\": {\n      \"text\": {\"literalString\": \"Welcome\"},\n      \"fontSize\": 24,\n      \"color\": \"#FF0000\"\n    }\n  }\n}\n</code></pre>"},{"location":"guides/theming/#2-maintain-accessibility","title":"2. Maintain Accessibility","text":"<ul> <li>Ensure sufficient color contrast (WCAG AA: 4.5:1 for normal text, 3:1 for large text)</li> <li>Test with screen readers</li> <li>Support keyboard navigation</li> <li>Test in both light and dark modes</li> </ul>"},{"location":"guides/theming/#3-use-design-tokens","title":"3. Use Design Tokens","text":"<p>Define reusable design tokens (colors, spacing, etc.) and reference them throughout your styles for consistency.</p>"},{"location":"guides/theming/#4-test-across-platforms","title":"4. Test Across Platforms","text":"<ul> <li>Test your theming on all target platforms (web, mobile, desktop)</li> <li>Verify both light and dark modes</li> <li>Check different screen sizes and orientations</li> <li>Ensure consistent brand experience across platforms</li> </ul>"},{"location":"guides/theming/#next-steps","title":"Next Steps","text":"<ul> <li>Custom Components: Build custom components with your styling</li> <li>Component Reference: See styling options for all components</li> <li>Client Setup: Set up the renderer in your app</li> </ul>"},{"location":"introduction/agent-ui-ecosystem/","title":"A2UI in the Agent Ecosystem","text":"<p>The space for agentic UI is evolving rapidly, with excellent tools emerging to solve different parts of the stack. A2UI is not a replacement for these frameworks\u2014it's a specialized protocol that solves the specific problem of interoperable, cross-platform, generative or template-based UI responses.</p>"},{"location":"introduction/agent-ui-ecosystem/#at-a-glance","title":"At a glance","text":"<p>The A2UI approach is to send JSON as a message to the client, which then uses a renderer to convert it into native UI components.  LLMs can generate the component layout on the fly or you can use a template.</p> <p>This makes it secure like data, and expressive like code.</p> <p>This rest of this page will help you understand A2UI in relationship to other options.</p>"},{"location":"introduction/agent-ui-ecosystem/#navigating-the-agentic-ui-ecosystem","title":"Navigating the Agentic UI Ecosystem","text":""},{"location":"introduction/agent-ui-ecosystem/#1-building-the-host-application-ui","title":"1. Building the \"Host\" Application UI","text":"<p>If you're building a full-stack application (the \"host\" UI that the user interacts with), in addition to building the actual UI, you may also utilize a framework (AG UI / CopilotKit, Vercel AI SDK, GenUI SDK for Flutter which already uses A2UI under the covers) to handle the \"pipes\": state synchronization, chat history, and input handling.</p> <p>Where A2UI fits: A2UI is complementary. If you connect your host application using AG UI, it can use A2UI as the data format for rendering responses from the host agent and also from third-party or remote agents. This gives you the best of both worlds: a rich, stateful host app that can safely render content from external agents it doesn't control.</p> <ul> <li>A2UI with A2A: You can send via A2A directly to a client front end.</li> <li>A2UI with AG UI: You can send via AG UI directly to a client front end.</li> <li>A2UI with REST, SSE, WebSockets and other transports are feasible but not yet available.</li> </ul>"},{"location":"introduction/agent-ui-ecosystem/#2-ui-as-a-resource-mcp-apps","title":"2. UI as a \"Resource\" (MCP Apps)","text":"<p>The Model Context Protocol (MCP) has recently introduced MCP Apps, a new standard consolidating the great work from MCP-UI and OpenAI to enable servers to provide interactive interfaces. This approach treats UI as a resource (accessed via a <code>ui://</code> URI) that tools can return, typically rendering pre-built HTML content within a sandboxed <code>iframe</code> to ensure isolation and security.</p> <p>How A2UI is different: A2UI takes a \"native-first\" approach that is distinct from the resource-fetching model of MCP Apps. Instead of retrieving an opaque payload to display in a sandbox, an A2UI agent sends a blueprint of native components. This allows the UI to inherit the host app's styling and accessibility features perfectly. In a multi-agent system, an orchestrator agent can easily understand the lightweight A2UI message content from a subagent, allowing for more fluid collaboration between agents.</p>"},{"location":"introduction/agent-ui-ecosystem/#3-platform-specific-ecosystems-openai-chatkit","title":"3. Platform-Specific Ecosystems (OpenAI ChatKit)","text":"<p>Tools like ChatKit offer a highly integrated, optimized experience for deploying agents specifically within the OpenAI ecosystem.</p> <p>How A2UI is different: A2UI is designed for developers building their own agentic surfaces across Web, Flutter, and native mobile, or for enterprise meshes (like A2A) where agents need to communicate across trust boundaries. A2UI gives the client more control over styling at the expense of the agent, in order to allow for greater visual consistency with the host client application.</p>"},{"location":"introduction/how-to-use/","title":"How Can I Use A2UI?","text":"<p>Choose the integration path that matches your role and use case.</p>"},{"location":"introduction/how-to-use/#three-paths","title":"Three Paths","text":""},{"location":"introduction/how-to-use/#path-1-building-a-host-application-frontend","title":"Path 1: Building a Host Application (Frontend)","text":"<p>Integrate A2UI rendering into your existing app or build a new agent-powered frontend.</p> <p>Choose a renderer:</p> <ul> <li>Web: Lit, Angular</li> <li>Mobile/Desktop: Flutter GenUI SDK</li> <li>React: Coming Q1 2026</li> </ul> <p>Quick setup:</p> <p>If we are using an Angular app, we can add the Angular renderer:</p> <pre><code>npm install @a2ui/angular \n</code></pre> <p>Connect to agent messages (SSE, WebSockets, or A2A) and customize styling to match your brand.</p> <p>Next: Client Setup Guide | Theming</p>"},{"location":"introduction/how-to-use/#path-2-building-an-agent-backend","title":"Path 2: Building an Agent (Backend)","text":"<p>Create an agent that generates A2UI responses for any compatible client.</p> <p>Choose your framework:</p> <ul> <li>Python: Google ADK, LangChain, custom</li> <li>Node.js: A2A SDK, Vercel AI SDK, custom</li> </ul> <p>Include the A2UI schema in your LLM prompts, generate JSONL messages, and stream to clients over SSE, WebSockets, or A2A.</p> <p>Next: Agent Development Guide</p>"},{"location":"introduction/how-to-use/#path-3-using-an-existing-framework","title":"Path 3: Using an Existing Framework","text":"<p>Use A2UI through frameworks with built-in support:</p> <ul> <li>AG UI / CopilotKit - Full-stack React framework with A2UI rendering</li> <li>Flutter GenUI SDK - Cross-platform generative UI (uses A2UI internally)</li> </ul> <p>Next: Agent UI Ecosystem | Where is A2UI Used?</p>"},{"location":"introduction/what-is-a2ui/","title":"What is A2UI?","text":"<p>A2UI (Agent to UI) is a declarative UI protocol for agent-driven interfaces. AI agents generate rich, interactive UIs that render natively across platforms (web, mobile, desktop) without executing arbitrary code.</p>"},{"location":"introduction/what-is-a2ui/#the-problem","title":"The Problem","text":"<p>Text-only agent interactions are inefficient:</p> <pre><code>User: \"Book a table for 2 tomorrow at 7pm\"\nAgent: \"Okay, for what day?\"\nUser: \"Tomorrow\"\nAgent: \"What time?\"\n...\n</code></pre> <p>Better: Agent generates a form with date picker, time selector, and submit button. Users interact with UI, not text.</p>"},{"location":"introduction/what-is-a2ui/#the-challenge","title":"The Challenge","text":"<p>In multi-agent systems, agents often run remotely (different servers, organizations). They can't directly manipulate your UI\u2014they must send messages.</p> <p>Traditional approach: Send HTML/JavaScript in iframes</p> <ul> <li>Heavy, visually disjointed</li> <li>Security complexity</li> <li>Doesn't match app styling</li> </ul> <p>Need: Transmit UI that's safe like data, expressive like code.</p>"},{"location":"introduction/what-is-a2ui/#the-solution","title":"The Solution","text":"<p>A2UI: JSON messages describing UI that:</p> <ul> <li>LLMs generate as structured output</li> <li>Travel over any transport (A2A, AG UI, SSE, WebSockets)</li> <li>Client renders using its own native components</li> </ul> <p>Result: Client controls security and styling, agent-generated UI feels native.</p>"},{"location":"introduction/what-is-a2ui/#example","title":"Example","text":"<pre><code>{\"surfaceUpdate\": {\"surfaceId\": \"booking\", \"components\": [\n  {\"id\": \"title\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Book Your Table\"}, \"usageHint\": \"h1\"}}},\n  {\"id\": \"datetime\", \"component\": {\"DateTimeInput\": {\"value\": {\"path\": \"/booking/date\"}, \"enableDate\": true}}},\n  {\"id\": \"submit-text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Confirm\"}}}},\n  {\"id\": \"submit-btn\", \"component\": {\"Button\": {\"child\": \"submit-text\", \"action\": {\"name\": \"confirm_booking\"}}}}\n]}}\n</code></pre> <pre><code>{\"dataModelUpdate\": {\"surfaceId\": \"booking\", \"contents\": [\n  {\"key\": \"booking\", \"valueMap\": [{\"key\": \"date\", \"valueString\": \"2025-12-16T19:00:00Z\"}]}\n]}}\n</code></pre> <pre><code>{\"beginRendering\": {\"surfaceId\": \"booking\", \"root\": \"title\"}}\n</code></pre> <p>Client renders these messages as native components (Angular, Flutter, React, etc.).</p>"},{"location":"introduction/what-is-a2ui/#core-value","title":"Core Value","text":"<p>1. Security: Declarative data, not code. Agent requests components from client's trusted catalog. No code execution risk.</p> <p>2. Native Feel: No iframes. Client renders with its own UI framework. Inherits app styling, accessibility, performance.</p> <p>3. Portability: One agent response works everywhere. Same JSON renders on web (Lit/Angular/React), mobile (Flutter/SwiftUI/Jetpack Compose), desktop.</p>"},{"location":"introduction/what-is-a2ui/#design-principles","title":"Design Principles","text":"<p>1. LLM-Friendly: Flat component list with ID references. Easy to generate incrementally, correct mistakes, stream.</p> <p>2. Framework-Agnostic: Agent sends abstract component tree. Client maps to native widgets (web/mobile/desktop).</p> <p>3. Separation of Concerns: Three layers\u2014UI structure, application state, client rendering. Enables data binding, reactive updates, clean architecture.</p>"},{"location":"introduction/what-is-a2ui/#what-a2ui-is-not","title":"What A2UI Is NOT","text":"<ul> <li>Not a framework (it's a protocol)</li> <li>Not a replacement for HTML (for agent-generated UIs, not static sites)</li> <li>Not a robust styling system (client controls styling with limited serverside styling support)</li> <li>Not limited to web (works on mobile and desktop)</li> </ul>"},{"location":"introduction/what-is-a2ui/#key-concepts","title":"Key Concepts","text":"<ul> <li>Surface: Canvas for components (dialog, sidebar, main view)</li> <li>Component: UI element (Button, TextField, Card, etc.)</li> <li>Data Model: Application state, components bind to it</li> <li>Catalog: Available component types</li> <li>Message: JSON object (<code>surfaceUpdate</code>, <code>dataModelUpdate</code>, <code>beginRendering</code>, etc.)</li> </ul> <p>For a comparison of similar projects, see Agent UI Ecosystem.</p>"},{"location":"introduction/where-is-it-used/","title":"Where is A2UI Used?","text":"<p>A2UI is being adopted by teams at Google and partner organizations to build the next generation of agent-driven applications. Here are real-world examples of where A2UI is making an impact.</p>"},{"location":"introduction/where-is-it-used/#production-deployments","title":"Production Deployments","text":""},{"location":"introduction/where-is-it-used/#google-opal-ai-mini-apps-for-everyone","title":"Google Opal: AI Mini-Apps for Everyone","text":"<p>Opal enables hundreds of thousands of people to build, edit, and share AI mini-apps using natural language\u2014no coding required.</p> <p>How Opal uses A2UI:</p> <p>The Opal team at Google has been a core contributor to A2UI from the beginning. They use A2UI to power the dynamic, generative UI system that makes Opal's AI mini-apps possible.</p> <ul> <li>Rapid prototyping: Build and test new UI patterns quickly</li> <li>User-generated apps: Anyone can create apps with custom UIs</li> <li>Dynamic interfaces: UIs adapt to each use case automatically</li> </ul> <p>\"A2UI is foundational to our work. It gives us the flexibility to let the AI drive the user experience in novel ways, without being constrained by a fixed front-end. Its declarative nature and focus on security allow us to experiment quickly and safely.\"</p> <p>\u2014 Dimitri Glazkov, Principal Engineer, Opal Team</p> <p>Learn more: opal.google</p>"},{"location":"introduction/where-is-it-used/#gemini-enterprise-custom-agents-for-business","title":"Gemini Enterprise: Custom Agents for Business","text":"<p>Gemini Enterprise enables businesses to build powerful, custom AI agents tailored to their specific workflows and data.</p> <p>How Gemini Enterprise uses A2UI:</p> <p>A2UI is being integrated to allow enterprise agents to render rich, interactive UIs within business applications\u2014going beyond simple text responses to guide employees through complex workflows.</p> <ul> <li>Data entry forms: AI-generated forms for structured data collection</li> <li>Approval dashboards: Dynamic UIs for review and approval processes</li> <li>Workflow automation: Step-by-step interfaces for complex tasks</li> <li>Custom enterprise UIs: Tailored interfaces for industry-specific needs</li> </ul> <p>\"Our customers need their agents to do more than just answer questions; they need them to guide employees through complex workflows. A2UI will allow developers building on Gemini Enterprise to have their agents generate the dynamic, custom UIs needed for any task, from data entry forms to approval dashboards, dramatically accelerating workflow automation.\"</p> <p>\u2014 Fred Jabbour, Product Manager, Gemini Enterprise</p> <p>Learn more: Gemini Enterprise</p>"},{"location":"introduction/where-is-it-used/#flutter-genui-sdk-generative-ui-for-mobile","title":"Flutter GenUI SDK: Generative UI for Mobile","text":"<p>The Flutter GenUI SDK brings dynamic, AI-generated UIs to Flutter applications across mobile, desktop, and web.</p> <p>How GenUI uses A2UI:</p> <p>GenUI SDK uses A2UI as the underlying protocol for communication between server-side agents and Flutter applications. When you use GenUI, you're using A2UI under the covers.</p> <ul> <li>Cross-platform support: Same agent works on iOS, Android, web, desktop</li> <li>Native performance: Flutter widgets rendered natively on each platform</li> <li>Brand consistency: UIs match your app's design system</li> <li>Server-driven UI: Agents control what's shown without app updates</li> </ul> <p>\"Our developers choose Flutter because it lets them quickly create expressive, brand-rich, custom design systems that feel great on every platform. A2UI was a great fit for Flutter's GenUI SDK because it ensures that every user, on every platform, gets a high quality native feeling experience.\"</p> <p>\u2014 Vijay Menon, Engineering Director, Dart &amp; Flutter</p> <p>Try it: - GenUI Documentation - Getting Started Video - Verdure Example (client-server A2UI sample)</p>"},{"location":"introduction/where-is-it-used/#partner-integrations","title":"Partner Integrations","text":""},{"location":"introduction/where-is-it-used/#ag-ui-copilotkit-full-stack-agentic-framework","title":"AG UI / CopilotKit: Full-Stack Agentic Framework","text":"<p>AG UI and CopilotKit provide a comprehensive framework for building agentic applications, with day-zero A2UI compatibility.</p> <p>How they work together:</p> <p>AG UI excels at creating high-bandwidth connections between custom frontends and their dedicated agents. By adding A2UI support, developers get the best of both worlds:</p> <ul> <li>State synchronization: AG UI handles app state and chat history</li> <li>A2UI rendering: Render dynamic UIs from third-party agents</li> <li>Multi-agent support: Coordinate UIs from multiple agents</li> <li>React integration: Seamless integration with React applications</li> </ul> <p>\"AG UI excels at creating a high-bandwidth connection between a custom-built front-end and its dedicated agent. By adding support for A2UI, we're giving developers the best of both worlds. They can now build rich, state-synced applications that can also render dynamic UIs from third-party agents via A2UI. It's a perfect match for a multi-agent world.\"</p> <p>\u2014 Atai Barkai, Founder of CopilotKit and AG UI</p> <p>Learn more: - AG UI - CopilotKit</p>"},{"location":"introduction/where-is-it-used/#googles-ai-powered-products","title":"Google's AI-Powered Products","text":"<p>As Google adopts AI across the company, A2UI provides a standardized way for AI agents to exchange user interfaces, not just text.</p> <p>Internal agent adoption:</p> <ul> <li>Multi-agent workflows: Multiple agents contribute to the same surface</li> <li>Remote agent support: Agents running on different services can provide UI</li> <li>Standardization: Common protocol across teams reduces integration overhead</li> <li>External exposure: Internal agents can be easily exposed externally (e.g., Gemini Enterprise)</li> </ul> <p>\"Much like A2A lets any agent talk to another agent regardless of platform, A2UI standardizes the user interface layer and supports remote agent use cases through an orchestrator. This has been incredibly powerful for internal teams, allowing them to rapidly develop agents where rich user interfaces are the norm, not the exception. As Google pushes further into generative UI, A2UI provides a perfect platform for server-driven UI that renders on any client.\"</p> <p>\u2014 James Wren, Senior Staff Engineer, AI Powered Google</p>"},{"location":"introduction/where-is-it-used/#community-projects","title":"Community Projects","text":"<p>The A2UI community is building exciting projects:</p>"},{"location":"introduction/where-is-it-used/#open-source-examples","title":"Open Source Examples","text":"<ul> <li>Restaurant Finder (samples/agent/adk/restaurant_finder)</li> <li>Table reservation with dynamic forms</li> <li>Gemini-powered agent</li> <li> <p>Full source code available</p> </li> <li> <p>Contact Lookup (samples/agent/adk/contact_lookup)</p> </li> <li>Search interface with results list</li> <li>A2A agent example</li> <li> <p>Demonstrates data binding</p> </li> <li> <p>Component Gallery (samples/client/angular - gallery mode)</p> </li> <li>Interactive showcase of all components</li> <li>Live examples with code</li> <li>Great for learning</li> </ul>"},{"location":"introduction/where-is-it-used/#community-contributions","title":"Community Contributions","text":"<p>Have you built something with A2UI? Share it with the community!</p>"},{"location":"introduction/where-is-it-used/#next-steps","title":"Next Steps","text":"<ul> <li>Quickstart Guide - Try the demo</li> <li>Agent Development - Build an agent</li> <li>Client Setup - Integrate a renderer</li> <li>Community - Join the community</li> </ul> <p>Using A2UI in production? Share your story on GitHub Discussions.</p>"},{"location":"introduction/who-is-it-for/","title":"Who is A2UI For?","text":"<p>Developers building AI agents with rich, interactive UIs.</p>"},{"location":"introduction/who-is-it-for/#three-audiences","title":"Three Audiences","text":""},{"location":"introduction/who-is-it-for/#1-host-app-developers-frontend","title":"1. Host App Developers (Frontend)","text":"<p>Build multi-agent platforms, enterprise assistants, or cross-platform apps where agents generate UI.</p> <p>Why A2UI:</p> <ul> <li>Brand control: client owns styling and design system</li> <li>Multi-agent: support local, remote, and third-party agents</li> <li>Secure: declarative data, no code execution</li> <li>Cross-platform: web, mobile, desktop</li> <li>Interoperable: open source, same spec with multiple renderers</li> </ul> <p>Get started: Client Setup | Theming | Custom Components</p>"},{"location":"introduction/who-is-it-for/#2-agent-developers-backendai","title":"2. Agent Developers (Backend/AI)","text":"<p>Build agents that generate forms, dashboards, and interactive workflows.</p> <p>Why A2UI:</p> <ul> <li>LLM-friendly: flat structure, easy to generate incrementally</li> <li>Rich interactions: beyond text (forms, tables, visualizations)</li> <li>Generations not tools: UI as part of the generated output from the agent</li> <li>Portable: one agent response works across all A2UI clients</li> <li>Streamable: progressive rendering as you generate</li> </ul> <p>Get started: Agent Development</p>"},{"location":"introduction/who-is-it-for/#3-platform-builders-sdk-creators","title":"3. Platform Builders (SDK Creators)","text":"<p>Build agent orchestration platforms, frameworks, or UI integrations.  </p> <p>Do you bring remote agents into your app?</p> <p>Do you ship your agent into other apps you don't necissarily control?</p> <p>Why A2UI:</p> <ul> <li>Standard protocol: interoperable with A2A and other transports</li> <li>Extensible: custom component catalogs</li> <li>Open source (Apache 2.0)</li> </ul> <p>Get started: Community | Roadmap</p>"},{"location":"introduction/who-is-it-for/#when-to-use-a2ui","title":"When to Use A2UI","text":"<p>\u2705 Agent-generated UI - Core purpose \u2705 Multi-agent systems - Standard protocol across trust boundaries \u2705 Cross-platform apps - One agent, many renderers (web/mobile/desktop) \u2705 Security critical - Declarative data, no code execution \u2705 Brand consistency - Client controls styling</p> <p>\u274c Static websites - Use HTML/CSS \u274c Simple text-only chat - Use Markdown \u274c Remote widgets not integrated with client - Use iframes, like MCP Apps</p> <p>\u274c Rapid UI + Agent app built together - Use AG UI / CopilotKit</p>"},{"location":"reference/components/","title":"Component Gallery","text":"<p>This page showcases all standard A2UI components with examples and usage patterns. For the complete technical specification, see the Standard Catalog Definition.</p>"},{"location":"reference/components/#layout-components","title":"Layout Components","text":""},{"location":"reference/components/#row","title":"Row","text":"<p>Horizontal layout container. Children are arranged left-to-right.</p> <pre><code>{\n  \"id\": \"toolbar\",\n  \"component\": {\n    \"Row\": {\n      \"children\": {\"explicitList\": [\"btn1\", \"btn2\", \"btn3\"]},\n      \"alignment\": \"center\"\n    }\n  }\n}\n</code></pre> <p>Properties:</p> <ul> <li><code>children</code>: Static array (<code>explicitList</code>) or dynamic <code>template</code></li> <li><code>distribution</code>: Horizontal distribution of children (<code>start</code>, <code>center</code>, <code>end</code>, <code>spaceBetween</code>, <code>spaceAround</code>, <code>spaceEvenly</code>)</li> <li><code>alignment</code>: Vertical alignment (<code>start</code>, <code>center</code>, <code>end</code>, <code>stretch</code>)</li> </ul>"},{"location":"reference/components/#column","title":"Column","text":"<p>Vertical layout container. Children are arranged top-to-bottom.</p> <pre><code>{\n  \"id\": \"content\",\n  \"component\": {\n    \"Column\": {\n      \"children\": {\"explicitList\": [\"header\", \"body\", \"footer\"]}\n    }\n  }\n}\n</code></pre> <p>Properties:</p> <ul> <li><code>children</code>: Static array (<code>explicitList</code>) or dynamic <code>template</code></li> <li><code>distribution</code>: Vertical distribution of children (<code>start</code>, <code>center</code>, <code>end</code>, <code>spaceBetween</code>, <code>spaceAround</code>, <code>spaceEvenly</code>)</li> <li><code>alignment</code>: Horizontal alignment (<code>start</code>, <code>center</code>, <code>end</code>, <code>stretch</code>)</li> </ul>"},{"location":"reference/components/#display-components","title":"Display Components","text":""},{"location":"reference/components/#text","title":"Text","text":"<p>Display text content with optional styling.</p> <pre><code>{\n  \"id\": \"title\",\n  \"component\": {\n    \"Text\": {\n      \"text\": {\"literalString\": \"Welcome to A2UI\"},\n      \"usageHint\": \"h1\"\n    }\n  }\n}\n</code></pre> <p><code>usageHint</code> values: <code>h1</code>, <code>h2</code>, <code>h3</code>, <code>h4</code>, <code>h5</code>, <code>caption</code>, <code>body</code></p>"},{"location":"reference/components/#image","title":"Image","text":"<p>Display images from URLs.</p> <pre><code>{\n  \"id\": \"logo\",\n  \"component\": {\n    \"Image\": {\n      \"url\": {\"literalString\": \"https://example.com/logo.png\"}\n    }\n  }\n}\n</code></pre>"},{"location":"reference/components/#icon","title":"Icon","text":"<p>Display icons using Material Icons or custom icon sets.</p> <pre><code>{\n  \"id\": \"check-icon\",\n  \"component\": {\n    \"Icon\": {\n      \"name\": {\"literalString\": \"check_circle\"}\n    }\n  }\n}\n</code></pre>"},{"location":"reference/components/#divider","title":"Divider","text":"<p>Visual separator line.</p> <pre><code>{\n  \"id\": \"separator\",\n  \"component\": {\n    \"Divider\": {\n      \"axis\": \"horizontal\"\n    }\n  }\n}\n</code></pre>"},{"location":"reference/components/#interactive-components","title":"Interactive Components","text":""},{"location":"reference/components/#button","title":"Button","text":"<p>Clickable button with action support.</p> <pre><code>{\n  \"id\": \"submit-btn-text\",\n  \"component\": {\n    \"Text\": {\n      \"text\": { \"literalString\": \"Submit\" }\n    }\n  }\n}\n{\n  \"id\": \"submit-btn\",\n  \"component\": {\n    \"Button\": {\n      \"child\": \"submit-btn-text\",\n      \"primary\": true,\n      \"action\": {\"name\": \"submit_form\"}\n    }\n  }\n}\n</code></pre> <p>Properties: - <code>child</code>: The ID of the component to display in the button (e.g., a Text or Icon). - <code>primary</code>: Boolean indicating if this is a primary action. - <code>action</code>: The action to perform on click.</p>"},{"location":"reference/components/#textfield","title":"TextField","text":"<p>Text input field.</p> <pre><code>{\n  \"id\": \"email-input\",\n  \"component\": {\n    \"TextField\": {\n      \"label\": {\"literalString\": \"Email Address\"},\n      \"text\": {\"path\": \"/user/email\"},\n      \"textFieldType\": \"shortText\"\n    }\n  }\n}\n</code></pre> <p><code>textFieldType</code> values: <code>date</code>, <code>longText</code>, <code>number</code>, <code>shortText</code>, <code>obscured</code></p> <p>Boolean toggle.</p> <pre><code>{\n  \"id\": \"terms-checkbox\",\n  \"component\": {\n    \"Checkbox\": {\n      \"label\": {\"literalString\": \"I agree to the terms\"},\n      \"value\": {\"path\": \"/form/agreedToTerms\"}\n    }\n  }\n}\n</code></pre>"},{"location":"reference/components/#container-components","title":"Container Components","text":""},{"location":"reference/components/#card","title":"Card","text":"<p>Container with elevation/border and padding.</p> <pre><code>{\n  \"id\": \"info-card\",\n  \"component\": {\n    \"Card\": {\n      \"child\": \"card-content\"\n    }\n  }\n}\n</code></pre>"},{"location":"reference/components/#modal","title":"Modal","text":"<p>Overlay dialog.</p> <pre><code>{\n  \"id\": \"confirmation-modal\",\n  \"component\": {\n    \"Modal\": {\n      \"entryPointChild\": \"open-modal-btn\",\n      \"contentChild\": \"modal-content\"\n    }\n  }\n}\n</code></pre>"},{"location":"reference/components/#tabs","title":"Tabs","text":"<p>Tabbed interface.</p> <pre><code>{\n  \"id\": \"settings-tabs\",\n  \"component\": {\n    \"Tabs\": {\n      \"tabItems\": [\n        {\"title\": {\"literalString\": \"General\"}, \"child\": \"general-settings\"},\n        {\"title\": {\"literalString\": \"Privacy\"}, \"child\": \"privacy-settings\"},\n        {\"title\": {\"literalString\": \"Advanced\"}, \"child\": \"advanced-settings\"}\n      ]\n    }\n  }\n}\n</code></pre> <p>Scrollable list of items.</p> <pre><code>{\n  \"id\": \"message-list\",\n  \"component\": {\n    \"List\": {\n      \"children\": {\n        \"template\": {\n          \"dataBinding\": \"/messages\",\n          \"componentId\": \"message-item\"\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/components/#common-properties","title":"Common Properties","text":"<p>Most components support these common properties:</p> <ul> <li><code>id</code> (required): Unique identifier for the component instance.</li> <li><code>weight</code>: Flex-grow value when the component is a direct child of a Row or Column. This property is specified alongside <code>id</code> and <code>component</code>.</li> </ul>"},{"location":"reference/components/#live-examples","title":"Live Examples","text":"<p>To see all components in action, run the component gallery demo:</p> <pre><code>cd samples/client/angular\nnpm start -- gallery\n</code></pre> <p>This launches a live gallery with all components, their variations, and interactive examples.</p>"},{"location":"reference/components/#further-reading","title":"Further Reading","text":"<ul> <li>Standard Catalog Definition: Complete technical specification</li> <li>Custom Components Guide: Build your own components</li> <li>Theming Guide: Style components to match your brand</li> </ul>"},{"location":"reference/messages/","title":"Message Types","text":"<p>This reference provides detailed documentation for all A2UI message types.</p>"},{"location":"reference/messages/#message-format","title":"Message Format","text":"<p>All A2UI messages are JSON objects sent as JSON Lines (JSONL). Each line contains exactly one message, and each message contains exactly one of these four keys:</p> <ul> <li><code>beginRendering</code></li> <li><code>surfaceUpdate</code></li> <li><code>dataModelUpdate</code></li> <li><code>deleteSurface</code></li> </ul>"},{"location":"reference/messages/#beginrendering","title":"beginRendering","text":"<p>Signals the client that it has enough information to perform the initial render of a surface.</p>"},{"location":"reference/messages/#schema","title":"Schema","text":"<pre><code>{\n  beginRendering: {\n    surfaceId: string;      // Required: Unique surface identifier\n    root: string;           // Required: The ID of the root component to render\n    catalogId?: string;     // Optional: URL of component catalog\n    styles?: object;        // Optional: Styling information\n  }\n}\n</code></pre>"},{"location":"reference/messages/#properties","title":"Properties","text":"Property Type Required Description <code>surfaceId</code> string \u2705 Unique identifier for this surface. <code>root</code> string \u2705 The <code>id</code> of the component that should be the root of the UI tree for this surface. <code>catalogId</code> string \u274c Identifier for the component catalog. Defaults to the v0.8 standard catalog if omitted. <code>styles</code> object \u274c Styling information for the UI, as defined by the catalog."},{"location":"reference/messages/#examples","title":"Examples","text":"<p>Basic render signal:</p> <pre><code>{\n  \"beginRendering\": {\n    \"surfaceId\": \"main\",\n    \"root\": \"root-component\"\n  }\n}\n</code></pre> <p>With a custom catalog:</p> <pre><code>{\n  \"beginRendering\": {\n    \"surfaceId\": \"custom-ui\",\n    \"root\": \"root-custom\",\n    \"catalogId\": \"https://my-company.com/a2ui/v0.8/my_custom_catalog.json\"\n  }\n}\n</code></pre>"},{"location":"reference/messages/#usage-notes","title":"Usage Notes","text":"<ul> <li>Must be sent after the client has received the component definitions for the root component and its initial children.</li> <li>The client should buffer <code>surfaceUpdate</code> and <code>dataModelUpdate</code> messages and only render the UI for a surface after receiving its corresponding <code>beginRendering</code> message.</li> </ul>"},{"location":"reference/messages/#surfaceupdate","title":"surfaceUpdate","text":"<p>Add or update components within a surface.</p>"},{"location":"reference/messages/#schema_1","title":"Schema","text":"<pre><code>{\n  surfaceUpdate: {\n    surfaceId: string;        // Required: Target surface\n    components: Array&lt;{       // Required: List of components\n      id: string;             // Required: Component ID\n      component: {            // Required: Wrapper for component data\n        [ComponentType]: {    // Required: Exactly one component type\n          ...properties       // Component-specific properties\n        }\n      }\n    }&gt;\n  }\n}\n</code></pre>"},{"location":"reference/messages/#properties_1","title":"Properties","text":"Property Type Required Description <code>surfaceId</code> string \u2705 ID of the surface to update <code>components</code> array \u2705 Array of component definitions"},{"location":"reference/messages/#component-object","title":"Component Object","text":"<p>Each object in the <code>components</code> array must have:</p> <ul> <li><code>id</code> (string, required): Unique identifier within the surface</li> <li><code>component</code> (object, required): A wrapper object that contains exactly one key, which is the component type (e.g., <code>Text</code>, <code>Button</code>).</li> </ul>"},{"location":"reference/messages/#examples_1","title":"Examples","text":"<p>Single component:</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main\",\n    \"components\": [\n      {\n        \"id\": \"greeting\",\n        \"component\": {\n          \"Text\": {\n            \"text\": {\"literalString\": \"Hello, World!\"},\n            \"usageHint\": \"h1\"\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Multiple components (adjacency list):</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main\",\n    \"components\": [\n      {\n        \"id\": \"root\",\n        \"component\": {\n          \"Column\": {\n            \"children\": {\"explicitList\": [\"header\", \"body\"]}\n          }\n        }\n      },\n      {\n        \"id\": \"header\",\n        \"component\": {\n          \"Text\": {\n            \"text\": {\"literalString\": \"Welcome\"}\n          }\n        }\n      },\n      {\n        \"id\": \"body\",\n        \"component\": {\n          \"Card\": {\n            \"child\": \"content\"\n          }\n        }\n      },\n      {\n        \"id\": \"content\",\n        \"component\": {\n          \"Text\": {\n            \"text\": {\"path\": \"/message\"}\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Updating existing component:</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main\",\n    \"components\": [\n      {\n        \"id\": \"greeting\",\n        \"component\": {\n          \"Text\": {\n            \"text\": {\"literalString\": \"Hello, Alice!\"},\n            \"usageHint\": \"h1\"\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>The component with <code>id: \"greeting\"</code> is updated (not duplicated).</p>"},{"location":"reference/messages/#usage-notes_1","title":"Usage Notes","text":"<ul> <li>One component must be designated as the <code>root</code> in the <code>beginRendering</code> message to serve as the tree root.</li> <li>Components form an adjacency list (flat structure with ID references).</li> <li>Sending a component with an existing ID updates that component.</li> <li>Children are referenced by ID.</li> <li>Components can be added incrementally (streaming).</li> </ul>"},{"location":"reference/messages/#errors","title":"Errors","text":"Error Cause Solution Surface not found <code>surfaceId</code> does not exist Ensure a unique <code>surfaceId</code> is used consistently for a given surface. Surfaces are implicitly created on first update. Invalid component type Unknown component type Check component type exists in the negotiated catalog. Invalid property Property doesn't exist for this type Verify against catalog schema. Circular reference Component references itself as a child Fix component hierarchy."},{"location":"reference/messages/#datamodelupdate","title":"dataModelUpdate","text":"<p>Update the data model that components bind to.</p>"},{"location":"reference/messages/#schema_2","title":"Schema","text":"<pre><code>{\n  dataModelUpdate: {\n    surfaceId: string;      // Required: Target surface\n    path?: string;          // Optional: Path to a location in the model\n    contents: Array&lt;{       // Required: Data entries\n      key: string;\n      valueString?: string;\n      valueNumber?: number;\n      valueBoolean?: boolean;\n      valueMap?: Array&lt;{...}&gt;;\n    }&gt;\n  }\n}\n</code></pre>"},{"location":"reference/messages/#properties_2","title":"Properties","text":"Property Type Required Description <code>surfaceId</code> string \u2705 ID of the surface to update. <code>path</code> string \u274c Path to a location within the data model (e.g., 'user'). If omitted, the update applies to the root. <code>contents</code> array \u2705 An array of data entries as an adjacency list. Each entry has a <code>key</code> and a typed <code>value*</code> property."},{"location":"reference/messages/#the-contents-adjacency-list","title":"The <code>contents</code> Adjacency List","text":"<p>The <code>contents</code> array is a list of key-value pairs. Each object in the array must have a <code>key</code> and exactly one <code>value*</code> property (<code>valueString</code>, <code>valueNumber</code>, <code>valueBoolean</code>, or <code>valueMap</code>). This structure is LLM-friendly and avoids issues with inferring types from a generic <code>value</code> field.</p>"},{"location":"reference/messages/#examples_2","title":"Examples","text":"<p>Initialize entire model:</p> <p>If <code>path</code> is omitted, <code>contents</code> replaces the entire data model for the surface.</p> <pre><code>{\n  \"dataModelUpdate\": {\n    \"surfaceId\": \"main\",\n    \"contents\": [\n      {\n        \"key\": \"user\",\n        \"valueMap\": [\n          { \"key\": \"name\", \"valueString\": \"Alice\" },\n          { \"key\": \"email\", \"valueString\": \"alice@example.com\" }\n        ]\n      },\n      { \"key\": \"items\", \"valueMap\": [] }\n    ]\n  }\n}\n</code></pre> <p>Update nested property:</p> <p>If <code>path</code> is provided, <code>contents</code> updates the data at that location.</p> <pre><code>{\n  \"dataModelUpdate\": {\n    \"surfaceId\": \"main\",\n    \"path\": \"user\",\n    \"contents\": [\n      { \"key\": \"email\", \"valueString\": \"alice@newdomain.com\" }\n    ]\n  }\n}\n</code></pre> <p>This will change <code>/user/email</code> without affecting <code>/user/name</code>.</p>"},{"location":"reference/messages/#usage-notes_2","title":"Usage Notes","text":"<ul> <li>Data model is per-surface.</li> <li>Components automatically re-render when their bound data changes.</li> <li>Prefer granular updates to specific paths over replacing the entire model.</li> <li>Data model is a plain JSON object.</li> <li>Any data transformation (e.g., formatting a date) must be done by the server before sending the <code>dataModelUpdate</code> message.</li> </ul>"},{"location":"reference/messages/#deletesurface","title":"deleteSurface","text":"<p>Remove a surface and all its components and data.</p>"},{"location":"reference/messages/#schema_3","title":"Schema","text":"<pre><code>{\n  deleteSurface: {\n    surfaceId: string;        // Required: Surface to delete\n  }\n}\n</code></pre>"},{"location":"reference/messages/#properties_3","title":"Properties","text":"Property Type Required Description <code>surfaceId</code> string \u2705 ID of the surface to delete"},{"location":"reference/messages/#examples_3","title":"Examples","text":"<p>Delete a surface:</p> <pre><code>{\n  \"deleteSurface\": {\n    \"surfaceId\": \"modal\"\n  }\n}\n</code></pre> <p>Delete multiple surfaces:</p> <pre><code>{\"deleteSurface\": {\"surfaceId\": \"sidebar\"}}\n{\"deleteSurface\": {\"surfaceId\": \"content\"}}\n</code></pre>"},{"location":"reference/messages/#usage-notes_3","title":"Usage Notes","text":"<ul> <li>Removes all components associated with the surface</li> <li>Clears the data model for the surface</li> <li>Client should remove the surface from the UI</li> <li>Safe to delete non-existent surface (no-op)</li> <li>Use when closing modals, dialogs, or navigating away</li> </ul>"},{"location":"reference/messages/#errors_1","title":"Errors","text":"Error Cause Solution (None - deletes are idempotent)"},{"location":"reference/messages/#message-ordering","title":"Message Ordering","text":""},{"location":"reference/messages/#requirements","title":"Requirements","text":"<ol> <li><code>beginRendering</code> must come after the initial <code>surfaceUpdate</code> messages for that surface.</li> <li><code>surfaceUpdate</code> can come before or after <code>dataModelUpdate</code>.</li> <li>Messages for different surfaces are independent.</li> <li>Multiple messages can update the same surface incrementally.</li> </ol>"},{"location":"reference/messages/#recommended-order","title":"Recommended Order","text":"<pre><code>{\"surfaceUpdate\": {\"surfaceId\": \"main\", \"components\": [...]}}\n{\"dataModelUpdate\": {\"surfaceId\": \"main\", \"contents\": {...}}}\n{\"beginRendering\": {\"surfaceId\": \"main\", \"root\": \"root-id\"}}\n</code></pre>"},{"location":"reference/messages/#progressive-building","title":"Progressive Building","text":"<pre><code>{\"surfaceUpdate\": {\"surfaceId\": \"main\", \"components\": [...]}}  // Header\n{\"surfaceUpdate\": {\"surfaceId\": \"main\", \"components\": [...]}}  // Body\n{\"beginRendering\": {\"surfaceId\": \"main\", \"root\": \"root-id\"}} // Initial render\n{\"surfaceUpdate\": {\"surfaceId\": \"main\", \"components\": [...]}}  // Footer (after initial render)\n{\"dataModelUpdate\": {\"surfaceId\": \"main\", \"contents\": {...}}}   // Populate data\n</code></pre>"},{"location":"reference/messages/#validation","title":"Validation","text":"<p>All messages should be validated against:</p> <ul> <li>server_to_client.json: Message envelope schema</li> <li>standard_catalog_definition.json: Component schemas</li> </ul>"},{"location":"reference/messages/#further-reading","title":"Further Reading","text":"<ul> <li>Component Gallery: All available component types</li> <li>Data Binding Guide: How data binding works</li> <li>Agent Development Guide: Generate valid messages</li> </ul>"},{"location":"specification/v0.8-a2a-extension/","title":"A2UI Extension for A2A Protocol (v0.8)","text":"<p>Living Document</p> <p>This specification is automatically included from <code>specification/0.8/docs/a2ui_extension_specification.md</code>. Any updates to the specification will automatically appear here.</p> <p>Version Compatibility</p> <p>This extension specification applies to A2UI v0.8 and the A2A Protocol. For the base A2UI protocol, see v0.8 Protocol Specification.</p> <p>Related Documentation: - A2UI Protocol v0.8 (Stable) - A2A Protocol Documentation</p>"},{"location":"specification/v0.8-a2a-extension/#a2ui-agent-to-agent-ui-extension-spec","title":"A2UI (Agent-to-Agent UI) Extension Spec","text":""},{"location":"specification/v0.8-a2a-extension/#overview","title":"Overview","text":"<p>This extension implements the A2UI (Agent-to-Agent UI) spec, a format for agents to send streaming, interactive user interfaces to clients.</p>"},{"location":"specification/v0.8-a2a-extension/#extension-uri","title":"Extension URI","text":"<p>The URI of this extension is https://a2ui.org/a2a-extension/a2ui/v0.8</p> <p>This is the only URI accepted for this extension.</p>"},{"location":"specification/v0.8-a2a-extension/#core-concepts","title":"Core Concepts","text":"<p>The A2UI extension is built on the following main concepts:</p> <p>Surfaces: A \"Surface\" is a distinct, controllable region of the client's UI. The spec uses a surfaceId to direct updates to specific surfaces (e.g., a main content area, a side panel, or a new chat bubble). This allows a single agent stream to manage multiple UI areas independently.</p> <p>Catalog Definition Document: The a2ui extension is component-agnostic. All UI components (e.g., Text, Row, Button) and their stylings are defined in a separate Catalog Definition Schema. This allows clients and servers to negotiate which catalog to use.</p> <p>Schemas: The a2ui extension is defined by three primary JSON schemas:</p> <p>Catalog Definition Schema: A standard format for defining a library of components and styles.</p> <p>Server-to-Client Message Schema: The core wire format for messages sent from the agent to the client (e.g., surfaceUpdate, dataModelUpdate).</p> <p>Client-to-Server Event Schema: The core wire format for messages sent from the client to the agent (e.g., userAction).</p> <p>Client Capabilities: The client sends its capabilities to the server in an <code>a2uiClientCapabilities</code> object. This object is included in the <code>metadata</code> field of every A2A <code>Message</code> sent from the client to the server.This object allows the client to declare which catalogs it supports.</p>"},{"location":"specification/v0.8-a2a-extension/#agent-card-details","title":"Agent Card details","text":"<p>Agents advertise their A2UI capabilities in their AgentCard within the <code>AgentCapabilities.extensions</code> list. The <code>params</code> object defines the agent's specific UI support.</p> <p>Example AgentExtension block:</p> <pre><code>{\n  \"uri\": \"https://a2ui.org/a2a-extension/a2ui/v0.8\",\n  \"description\": \"Ability to render A2UI\",\n  \"required\": false,\n  \"params\": {\n    \"supportedCatalogIds\": [\n      \"https://github.com/google/A2UI/blob/main/specification/0.8/json/standard_catalog_definition.json\",\n      \"https://my-company.com/a2ui/v0.8/my_custom_catalog.json\"\n    ],\n    \"acceptsInlineCatalogs\": true\n  }\n}\n</code></pre>"},{"location":"specification/v0.8-a2a-extension/#parameter-definitions","title":"Parameter Definitions","text":"<ul> <li><code>params.supportedCatalogIds</code>: (OPTIONAL) An array of strings, where each string is a URI pointing to a component Catalog Definition Schema that the agent can generate.</li> <li><code>params.acceptsInlineCatalogs</code>: (OPTIONAL) A boolean indicating if the agent can accept an <code>inlineCatalogs</code> array in the client's <code>a2uiClientCapabilities</code>. If omitted, this defaults to <code>false</code>.</li> </ul>"},{"location":"specification/v0.8-a2a-extension/#extension-activation","title":"Extension Activation","text":"<p>Clients indicate their desire to use the A2UI extension by specifying it via the transport-defined A2A extension activation mechanism.</p> <p>For JSON-RPC and HTTP transports, this is indicated via the X-A2A-Extensions HTTP header.</p> <p>For gRPC, this is indicated via the X-A2A-Extensions metadata value.</p> <p>Activating this extension implies that the server can send A2UI-specific messages (like surfaceUpdate) and the client is expected to send A2UI-specific events (like userAction).</p>"},{"location":"specification/v0.8-a2a-extension/#data-encoding","title":"Data Encoding","text":"<p>A2UI messages are encoded as an A2A <code>DataPart</code>.</p> <p>To identify a <code>DataPart</code> as containing A2UI data, it must have the following metadata:</p> <ul> <li><code>mimeType</code>: <code>application/json+a2ui</code></li> </ul> <p>The <code>data</code> field of the <code>DataPart</code> contains the A2UI JSON message (e.g., <code>surfaceUpdate</code>, <code>userAction</code>).</p> <p>Example A2UI DataPart:</p> <pre><code>{\n  \"data\": {\n    \"beginRendering\": {\n      \"surfaceId\": \"outlier_stores_map_surface\",\n    }\n  },\n  \"kind\": \"data\",\n  \"metadata\": {\n    \"mimeType\": \"application/json+a2ui\"\n  }\n}\n</code></pre>"},{"location":"specification/v0.8-a2ui/","title":"A2UI Protocol v0.8 (Stable)A2UI (Agent to UI) Protocol","text":"<p>Stable Release</p> <p>Version 0.8 is the current stable release, recommended for production use.</p> <p>Living Document</p> <p>This specification is automatically included from <code>specification/0.8/docs/a2ui_protocol.md</code>. Any updates to the specification will automatically appear here.</p> <p>See also: - v0.9 Protocol Specification (Draft) - Evolution Guide: v0.8 \u2192 v0.9 - A2A Extension Specification (for v0.8)</p> <p>A Specification for a JSONL-Based, Streaming UI Protocol</p> <p>Created: Sep 19, 2025 Updated: Nov 12, 2025</p>"},{"location":"specification/v0.8-a2ui/#design-requirements","title":"Design Requirements","text":"<p>The A2UI (Agent to UI) protocol should be a system where an LLM can stream a platform-agnostic, abstract UI definition to a client, which then renders it progressively using a native widget set. Every major design choice is traced back to the core challenges of LLM generation, perceived performance, and platform independence.</p>"},{"location":"specification/v0.8-a2ui/#requirement-the-protocol-must-be-easily-generated-by-a-transformer-large-language-model-llm","title":"Requirement: The protocol must be easily generated by a Transformer Large Language Model (LLM)","text":"<p>This is the most critical driver. This requirement directly leads to several design choices:</p> <p>Declarative, Simple Structure: The protocol should use a straightforward, declarative format (\"this is a column with these children\") rather than an imperative one (\"now, add a column; then, append a text widget to it\"). LLMs excel at generating structured, declarative data.</p> <p>Flat Component List (Adjacency List): Requiring an LLM to generate a perfectly nested JSON tree in a single pass is difficult and error-prone. A flat list of components, where relationships are defined by simple string IDs, is much easier to generate piece by piece. The model can \"think\" of a component, give it an ID, and then reference that ID later without worrying about tree depth or object nesting.</p> <p>Stateless Messages: Each JSONL message is a self-contained unit of information (componentUpdate, dataModelUpdate). This is ideal for a streaming LLM, which can output these messages incrementally as it processes a request.</p>"},{"location":"specification/v0.8-a2ui/#requirement-the-ui-must-render-progressively-for-a-fast-responsive-user-experience","title":"Requirement: The UI must render progressively for a fast, responsive user experience","text":"<p>The system must feel fast to the user, even if the full UI is complex and takes time to generate.</p> <p>Streaming via JSONL/SSE: This is a direct solution. The client doesn't have to wait for a single, massive JSON payload. It can start receiving and processing UI components immediately, improving perceived performance.</p>"},{"location":"specification/v0.8-a2ui/#requirement-the-protocol-must-be-platform-agnostic","title":"Requirement: The protocol must be platform-agnostic","text":"<p>The same server-side logic should be able to render a UI on a Flutter app, a web browser, or potentially other platforms without modification.</p> <p>Client-Defined widget catalog: This is the core of the platform-agnostic design. The protocol should define an abstract component tree (e.g., \"I need a Card with a Row inside\"). It is the client's responsibility to map these abstract types to its native widget implementations (a Flutter Card widget, an HTML <code>&lt;div&gt;</code> with card styling, etc.). The server only needs to know the names of the components the client supports.</p>"},{"location":"specification/v0.8-a2ui/#requirement-state-management-must-be-efficient-and-decoupled-from-the-ui-structure","title":"Requirement: State management must be efficient and decoupled from the UI structure","text":"<p>Changing a piece of text in the UI should not require resending the entire UI definition.</p> <p>Separation of Data and Components: Having distinct componentUpdate and data model update messages is key. The UI structure can be sent once, and subsequent updates can be small dataModelUpdate messages that only contain the changed data.</p>"},{"location":"specification/v0.8-a2ui/#requirement-the-communication-architecture-must-be-robust-and-scalable","title":"Requirement: The communication architecture must be robust and scalable","text":"<p>The system needs a clear, reliable way to handle both server-pushed UI and client-initiated events.</p> <p>Unidirectional UI Stream: Using a one-way stream (SSE) for UI updates simplifies the client's logic. It only needs to listen and react. This is a more robust pattern for server-push than trying to manage a complex bidirectional channel.</p> <p>Event Handling: Event handling is done via an A2A message from the client to the server agent</p>"},{"location":"specification/v0.8-a2ui/#introduction","title":"Introduction","text":"<p>The A2UI Protocol is a protocol designed for rendering user interfaces from a stream of JSON objects sent from a server. Its core philosophy emphasizes a clean separation of UI structure and application data, enabling progressive rendering as the client processes each message.</p> <p>The protocol is designed to be \"LLM-friendly,\" meaning its structure is declarative and straightforward, making it easy for a generative model to produce. A core feature of A2UI is its extensible component model. The set of available UI components is not fixed by the protocol but is defined in a separate Catalog, allowing for platform-specific or custom components.</p> <p>Communication occurs via a JSON Lines (JSONL) stream. The client parses each line as a distinct message and incrementally builds the UI. The server-to-client protocol defines four message types:</p> <ul> <li><code>surfaceUpdate</code>: Provides a list of component definitions to be added to or updated in a specific UI area called a \"surface.\"</li> <li><code>dataModelUpdate</code>: Provides new data to be inserted into or to replace a surface's data model. Each surface has its own data model.</li> <li><code>beginRendering</code>: Signals to the client that it has enough information to perform the initial render, specifying the ID of the root component and, optionally, the component catalog to use.</li> <li><code>deleteSurface</code>: Explicitly removes a surface and its contents from the UI.</li> </ul> <p>Client-to-server communication for user interactions is handled separately via an A2A message. This message can be one of two types:</p> <ul> <li><code>userAction</code>: Reports a user-initiated action from a component.</li> <li><code>error</code>: Reports a client-side error.   This keeps the primary data stream unidirectional.</li> </ul>"},{"location":"specification/v0.8-a2ui/#section-1-foundational-architecture-and-data-flow","title":"Section 1: Foundational Architecture and Data Flow","text":"<p>This document specifies the architecture and data formats for the A2UI protocol. The design is guided by principles of strict separation of concerns, versioning, and progressive rendering.</p>"},{"location":"specification/v0.8-a2ui/#11-core-philosophy-decoupling-and-contracts","title":"1.1. Core Philosophy: Decoupling and Contracts","text":"<p>The central philosophy of A2UI is the decoupling of three key elements:</p> <ol> <li>The Component Tree (The Structure): A server-provided tree of abstract components that describes the UI's structure. This is defined by <code>surfaceUpdate</code> messages.</li> <li>The Data Model (The State): A server-provided JSON object containing the dynamic values that populate the UI, such as text, booleans, or lists. This is managed via <code>dataModelUpdate</code> messages.</li> <li>The Widget Registry (The \"Catalog\"): A client-defined mapping of component types (e.g., \"Row\", \"Text\") to concrete, native widget implementations. This registry is part of the client application, not the protocol stream. The server must generate components that the target client's registry understands.</li> </ol>"},{"location":"specification/v0.8-a2ui/#12-the-jsonl-stream-the-unit-of-communication","title":"1.2. The JSONL Stream: The Unit of Communication","text":"<p>All UI descriptions are transmitted from the server to the client as a stream of JSON objects, formatted as JSON Lines (JSONL). Each line is a separate, compact JSON object representing a single message. This allows the client to parse and process each part of the UI definition as it arrives, enabling progressive rendering.</p>"},{"location":"specification/v0.8-a2ui/#13-surfaces-managing-multiple-ui-regions","title":"1.3. Surfaces: Managing Multiple UI Regions","text":"<p>A Surface is a contiguous portion of screen real estate into which a A2UI UI can be rendered. The protocol introduces the concept of a <code>surfaceId</code> to uniquely identify and manage these areas. This allows a single A2UI stream to control multiple, independent UI regions simultaneously. Each surface has a separate root component and a separate hierarchy of components. Each surface has a separate data model, to avoid collision of keys when working with a large number of surfaces.</p> <p>For example, in a chat application, each AI-generated response could be rendered into a separate surface within the conversation history. A separate, persistent surface could be used for a side panel that displays related information.</p> <p>The <code>surfaceId</code> is a property within each server-to-client message that directs changes to the correct area. It is used with messages like <code>beginRendering</code>, <code>surfaceUpdate</code>, <code>dataModelUpdate</code>, and <code>deleteSurface</code> to target a specific surface.</p>"},{"location":"specification/v0.8-a2ui/#14-data-flow-model","title":"1.4. Data Flow Model","text":"<p>The A2UI protocol is composed of a server-to-client stream describing UI and individual events sent to the server. The client consumes the stream, builds the UI, and renders it. Communication occurs via a JSON Lines (JSONL) stream, typically transported over Server-Sent Events (SSE).</p> <ol> <li>Server Stream: The server begins sending the JSONL stream over an SSE connection.</li> <li> <p>Client-Side Buffering: The client receives messages and buffers them:</p> <ul> <li><code>surfaceUpdate</code>: Component definitions are stored in a <code>Map&lt;String, Component&gt;</code>, organized by <code>surfaceId</code>. If a surface doesn't exist, it is created.</li> <li><code>dataModelUpdate</code>: The client's internal JSON data model is built or updated.</li> </ul> </li> <li> <p>Render Signal: The server sends a <code>beginRendering</code> message with the <code>root</code> component's ID. This prevents a \"flash of incomplete content.\" The client buffers incoming components and data but waits for this explicit signal before attempting the first render, ensuring the initial view is coherent.</p> </li> <li>Client-Side Rendering: The client, now in a \"ready\" state, starts at the <code>root</code> component. It recursively walks the component tree by looking up component IDs in its buffer. It resolves any data bindings against the data model and uses its <code>WidgetRegistry</code> to instantiate native widgets.</li> <li>User Interaction and Event Handling: The user interacts with a rendered widget (e.g., taps a button). The client constructs a <code>userAction</code> JSON payload, resolving any data bindings from the component's <code>action.context</code>. It sends this payload to the server via an A2A message.</li> <li>Dynamic Updates: The server processes the <code>userAction</code>. If the UI needs to change in response, the server sends new <code>surfaceUpdate</code> and <code>dataModelUpdate</code> messages over the original SSE stream. As these arrive, the client updates its component buffer and data model, and the UI re-renders to reflect the changes. The server can also send <code>deleteSurface</code> to remove a UI region.</li> </ol> sequenceDiagram     participant Server     participant Client      Server-&gt;&gt;+Client: SSE Connection (JSONL Stream)     Client-&gt;&gt;Client: 1. Parse JSONL message     loop Until 'beginRendering'         Client-&gt;&gt;Client: 2a. Process surfaceUpdate         Client-&gt;&gt;Client: 2b. Process dataModelUpdate     end     Client-&gt;&gt;Client: 3. Process beginRendering (rootId: 'root', isReady: true)     Note right of Client: 4. Triggers UI build for a surface     Client-&gt;&gt;Client: 5. Build widget tree from 'root'     Client-&gt;&gt;Client: 6. Resolve data bindings     Client-&gt;&gt;Client: 7. Look up widgets in WidgetRegistry     Client--&gt;&gt;-Server: (UI is rendered)      Note over Client: 8. User interacts with UI (e.g., clicks button)     Client-&gt;&gt;Client: 9. Construct userAction payload     Client-&gt;&gt;+Server: 10. A2A Message sent to server (Client Event JSON with userAction)     Server--&gt;&gt;-Client: 11. OK      loop Dynamic Updates in Response to Event         Server-&gt;&gt;+Client: surfaceUpdate, dataModelUpdate, or deleteSurface (via SSE)         Client-&gt;&gt;Client: Update component map, data model, or remove surface         Note right of Client: Triggers UI rebuild         Client--&gt;&gt;-Server: (UI is updated)     end"},{"location":"specification/v0.8-a2ui/#15-full-stream-example","title":"1.5. Full Stream Example","text":"<p>The following is a complete, minimal example of a JSONL stream that renders a user profile card.</p> <pre><code>{\"surfaceUpdate\": {\"components\": [{\"id\": \"root\", \"component\": {\"Column\": {\"children\": {\"explicitList\": [\"profile_card\"]}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"profile_card\", \"component\": {\"Card\": {\"child\": \"card_content\"}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"card_content\", \"component\": {\"Column\": {\"children\": {\"explicitList\": [\"header_row\", \"bio_text\"]}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"header_row\", \"component\": {\"Row\": {\"alignment\": \"center\", \"children\": {\"explicitList\": [\"avatar\", \"name_column\"]}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"avatar\", \"component\": {\"Image\": {\"url\": {\"literalString\": \"https://www.example.com/profile.jpg\"}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"name_column\", \"component\": {\"Column\": {\"alignment\": \"start\", \"children\": {\"explicitList\": [\"name_text\", \"handle_text\"]}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"name_text\", \"component\": {\"Text\": {\"usageHint\": \"h3\", \"text\": {\"literalString\": \"A2A Fan\"}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"handle_text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"@a2a_fan\"}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"bio_text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Building beautiful apps from a single codebase.\"}}}}]}}\n{\"dataModelUpdate\": {\"contents\": {}}}\n{\"beginRendering\": {\"root\": \"root\"}}\n</code></pre>"},{"location":"specification/v0.8-a2ui/#section-2-the-component-model","title":"Section 2: The Component Model","text":"<p>A2UI's component model is designed for flexibility, separating the protocol from the component set.</p>"},{"location":"specification/v0.8-a2ui/#21-catalog-negotiation","title":"2.1. Catalog Negotiation","text":"<p>A Catalog defines the contract between the server and the client for the UI that can be rendered. It contains a list of supported component types (e.g., <code>Row</code>, <code>Text</code>), their properties, and available styles. A catalog is defined by a Catalog Definition Document.</p> <p>There is a Standard Catalog associated with each version of the A2UI protocol. For v0.8, its identifier is <code>https://github.com/google/A2UI/blob/main/specification/0.8/json/standard_catalog_definition.json</code>.</p> <p>Catalog IDs are simple string identifiers. While they can be anything, it is conventional to use a URI within a domain that you own, to simplify debugging, avoid confusion, and avoid name collisions. Furthermore, if any changes are made to a catalog that could break compatibility between an agent and renderer, a new <code>catalogId</code> must be assigned. This ensures clear versioning and prevents unexpected behavior if an agent has changes but the client does not, or vice versa.</p> <p>The negotiation process allows the client and server to agree on which catalog to use for a given UI surface. This process is designed to be flexible, supporting standard, custom, and even dynamically-defined catalogs.</p> <p>The flow is as follows:</p>"},{"location":"specification/v0.8-a2ui/#1-server-advertises-capabilities","title":"1. Server Advertises Capabilities","text":"<p>The server (agent) advertises its capabilities in its Agent Card as part of the A2A protocol. For A2UI, this includes which catalogs it supports and whether it can handle catalogs defined inline by the client.</p> <ul> <li><code>supportedCatalogIds</code> (array of strings, optional): A list of IDs for all pre-defined catalogs the agent is known to support.</li> <li><code>acceptsInlineCatalogs</code> (boolean, optional): If <code>true</code>, the server can process <code>inlineCatalogs</code> sent by the client. Defaults to <code>false</code>.</li> </ul> <p>Example Server Agent Card Snippet: <pre><code>{\n  \"name\": \"Restaurant Finder\",\n  \"capabilities\": {\n    \"extensions\": [\n      {\n        \"uri\": \"https://a2ui.org/a2a-extension/a2ui/v0.8\",\n        \"params\": {\n          \"supportedCatalogIds\": [\n            \"https://github.com/google/A2UI/blob/main/specification/0.8/json/standard_catalog_definition.json\",\n            \"https://my-company.com/a2ui/v0.8/my_custom_catalog.json\"\n          ],\n          \"acceptsInlineCatalogs\": true\n        }\n      }\n    ]\n  }\n}\n</code></pre></p> <p>Note that this is not a strict contract and purely included as a signal to help orchestrators and clients identify agents with matching UI capabilities. At runtime, orchestrating agents may dynamically delegate tasks to subagents which support additional catalogs that the orchestrating agent did not advertise. Thus, clients should consider the advertised supportedCatalogIds as a subset of the true catalogs that the agent or its subagents may support.</p>"},{"location":"specification/v0.8-a2ui/#2-client-declares-supported-catalogs","title":"2. Client Declares Supported Catalogs","text":"<p>In every message sent to the server, the client includes an <code>a2uiClientCapabilities</code> object within the A2A <code>Message</code> metadata. This object informs the agent server of all catalogs the client can render.</p> <ul> <li><code>supportedCatalogIds</code> (array of strings, required): A list of identifiers for all pre-defined catalogs the client supports. The client must explicitly include the standard catalog ID here if it supports the standard catalog. The contents of these catalogs are expected to be compiled into the agent server and not downloaded at runtime, in order to prevent malicious content being injected into the prompt dynamically, and ensure predictable results.</li> <li><code>inlineCatalogs</code> (array of objects, optional): An array of full Catalog Definition Documents. This allows a client to provide custom, on-the-fly catalogs, typically for use in local development workflows where it is faster to update a catalog in one place on the client. This may only be provided if the server has advertised <code>acceptsInlineCatalogs: true</code>.</li> </ul> <p>Example A2A Message with Client Capabilities: <pre><code>{\n  \"metadata\": {\n    \"a2uiClientCapabilities\": {\n      \"supportedCatalogIds\": [\n        \"https://github.com/google/A2UI/blob/main/specification/0.8/json/standard_catalog_definition.json\",\n        \"https://my-company.com/a2ui_catalogs/custom-reporting-catalog-1.2\"\n      ],\n      \"inlineCatalogs\": [\n        {\n          \"catalogId\": \"https://my-company.com/inline_catalogs/temp-signature-pad-catalog\",\n          \"components\": {\n            \"SignaturePad\": {\n              \"type\": \"object\",\n              \"properties\": { \"penColor\": { \"type\": \"string\" } }\n            }\n          },\n          \"styles\": {}\n        }\n      ]\n    }\n  },\n  \"message\": {\n    \"prompt\": {\n      \"text\": \"Find me a good restaurant\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"specification/v0.8-a2ui/#3-server-chooses-catalog-and-renders","title":"3. Server Chooses Catalog and Renders","text":"<p>The server receives the client's capabilities and chooses a catalog to use for a specific UI surface. The server specifies its choice in the <code>beginRendering</code> message using the <code>catalogId</code> field.</p> <ul> <li><code>catalogId</code> (string, optional): The identifier of the chosen catalog. This ID must be one of the <code>supportedCatalogIds</code> or the <code>catalogId</code> from one of the <code>inlineCatalogs</code> provided by the client.</li> </ul> <p>If the <code>catalogId</code> is omitted, the client MUST default to the standard catalog for the protocol version (<code>https://github.com/google/A2UI/blob/main/specification/0.8/json/standard_catalog_definition.json</code>).</p> <p>Example <code>beginRendering</code> Message: <pre><code>{\n  \"beginRendering\": {\n    \"surfaceId\": \"unique-surface-1\",\n    \"catalogId\": \"https://my-company.com/inline_catalogs/temp-signature-pad-catalog\",\n    \"root\": \"root-component-id\"\n  }\n}\n</code></pre></p> <p>Each surface can use a different catalog, providing a high degree of flexibility, particularly in multi-agent systems where different agents may support different catalogs.</p>"},{"location":"specification/v0.8-a2ui/#schemas-for-developers","title":"Schemas for Developers","text":"<p>When building an agent, it is recommended to use a resolved schema that includes the specific component catalog you are targeting (e.g., a custom schema combining <code>server_to_client.json</code> with your <code>https://my-company.com/a2ui_catalogs/custom-reporting-catalog-1.2</code> definition). This provides the LLM with a strict definition of all available components and their properties, as well as the catalog-specific styles, leading to more reliable UI generation. The generic <code>server_to_client.json</code> is the abstract wire protocol, while the resolved schema is the concrete tool for generation.</p> <p>In order to do the substitution, based on the standard <code>server_to_client_schema</code> and a <code>custom_catalog_definition</code> object, you can use JSON manipulation logic similar to:</p> <pre><code>component_properties = custom_catalog_definition[\"components\"]\nstyle_properties = custom_catalog_definition[\"components\"]\nresolved_schema = copy.deepcopy(server_to_client_schema)\n\nresolved_schema[\"properties\"][\"surfaceUpdate\"][\"properties\"][\"components\"][\"items\"][\"properties\"][\"component\"][\"properties\"] = component_properties\nresolved_schema[\"properties\"][\"beginRendering\"][\"properties\"][\"styles\"][\"properties\"] = style_properties\n</code></pre> <p>See <code>server_to_client_with_standard_catalog.json</code> for an example of a resolved  schema which has the components substituted in.</p>"},{"location":"specification/v0.8-a2ui/#22-the-surfaceupdate-message","title":"2.2. The <code>surfaceUpdate</code> Message","text":"<p>This message is the primary way UI structure is defined. It contains a <code>surfaceId</code> and a <code>components</code> array.</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main_content_area\",\n    \"components\": [\n      {\n        \"id\": \"unique-component-id\",\n        \"component\": {\n          \"Text\": {\n            \"text\": { \"literalString\": \"Hello, World!\" }\n          }\n        }\n      },\n      {\n        \"id\": \"another-component-id\",\n        \"component\": { ... }\n      }\n    ]\n  }\n}\n</code></pre> <ul> <li><code>components</code>: A required flat list of component instances.</li> </ul>"},{"location":"specification/v0.8-a2ui/#23-the-component-object","title":"2.3. The Component Object","text":"<p>Each object in the <code>components</code> array has the following structure:</p> <ul> <li><code>id</code>: A required, unique string that identifies this specific component instance. This is used for parent-child references.</li> <li><code>component</code>: A required object that defines the component's type and properties.</li> </ul>"},{"location":"specification/v0.8-a2ui/#24component-generic-object","title":"2.4.<code>component</code> (Generic Object)","text":"<p>On the wire, this object is generic. Its structure is not defined by the core A2UI protocol. Instead, its validation is based on the active Catalog. It is a wrapper object that must contain exactly one key, where the key is the string name of the component type from the catalog (e.g., <code>\"Text\"</code>, <code>\"Row\"</code>). The value is an object containing the properties for that component, as defined in the catalog.</p> <p>Example: A <code>Text</code> component:</p> <pre><code>\"component\": {\n  \"Text\": {\n    \"text\": { \"literalString\": \"This is text\" }\n  }\n}\n</code></pre> <p>A <code>Button</code> component:</p> <pre><code>\"component\": {\n  \"Button\": {\n    \"label\": { \"literalString\": \"Click Me\" },\n    \"action\": { \"name\": \"submit_form\" }\n  }\n}\n</code></pre> <p>The full set of available component types and their properties is defined by a Catalog Schema, not in the core protocol schema.</p>"},{"location":"specification/v0.8-a2ui/#section-3-ui-composition","title":"Section 3: UI Composition","text":""},{"location":"specification/v0.8-a2ui/#31-the-adjacency-list-model","title":"3.1. The Adjacency List Model","text":"<p>The A2UI protocol defines the UI as a flat list of components. The tree structure is built implicitly using ID references. This is known as an adjacency list model.</p> <p>Container components (like <code>Row</code>, <code>Column</code>, <code>List</code>, <code>Card</code>) have properties that reference the <code>id</code> of their child component(s). The client is responsible for storing all components in a map (e.g., <code>Map&lt;String, Component&gt;</code>) and recreating the tree structure at render time.</p> <p>This model allows the server to send component definitions in any order, as long as all necessary components are present by the time <code>beginRendering</code> is sent.</p> flowchart TD     subgraph \"Server Stream (JSONL)\"         A(\"surfaceUpdatecomponents: [root, title, button, button_text]\")         B(\"beginRenderingroot: 'root'\")     end      subgraph \"Client-Side Buffer (Map)\"         C(\"root: {id: 'root', type: Column, children: ['title', 'button']}\")         D(\"title: {id: 'title', type: Text, text: 'Welcome'}\")         E(\"button: {id: 'button', type: Button, child: 'button_text'}\")         E_TEXT(\"button_text: {id: 'button_text', type: Text, text: 'Go'}\")     end      subgraph \"Rendered Widget Tree\"         F(Column) --&gt; G(Text: 'Welcome')         F --&gt; H(Button)         H --&gt; I(Text: 'Go')     end      A -- \"Parsed and stored\" --&gt; C     A -- \"Parsed and stored\" --&gt; D     A -- \"Parsed and stored\" --&gt; E     A -- \"Parsed and stored\" --&gt; E_TEXT      B -- \"Triggers build from buffer\" --&gt; F"},{"location":"specification/v0.8-a2ui/#32-container-children-explicitlist-vs-template","title":"3.2. Container Children: <code>explicitList</code> vs. <code>template</code>","text":"<p>Container components (<code>Row</code>, <code>Column</code>, <code>List</code>) define their children using a <code>children</code> object, which must contain either <code>explicitList</code> or <code>template</code>.</p> <ul> <li><code>explicitList</code>: An array of component <code>id</code> strings. This is used for static, known children.</li> <li><code>template</code>: An object used to render a dynamic list of children from a data-bound list.</li> </ul> <pre><code>{\n  \"type\": \"object\",\n  \"description\": \"Defines the children of a container component. Must contain exactly one of `explicitList` or `template`.\",\n  \"properties\": {\n    \"explicitList\": {\n      \"type\": \"array\",\n      \"description\": \"An ordered list of component IDs that are direct children.\",\n      \"items\": {\n        \"type\": \"string\",\n        \"description\": \"The ID of a child component.\"\n      }\n    },\n    \"template\": {\n      \"type\": \"object\",\n      \"description\": \"Defines a template for rendering dynamic lists of children.\",\n      \"properties\": {\n        \"dataBinding\": { \"$ref\": \"#/definitions/DataPath\" },\n        \"componentId\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the component to use as a template for each item in the data-bound list.\"\n        }\n      },\n      \"required\": [\"dataBinding\", \"componentId\"],\n      \"additionalProperties\": false\n    }\n  },\n  \"minProperties\": 1,\n  \"maxProperties\": 1\n}\n</code></pre>"},{"location":"specification/v0.8-a2ui/#33-dynamic-list-rendering-with-template","title":"3.3. Dynamic List Rendering with <code>template</code>","text":"<p>To render dynamic lists, a container uses the <code>template</code> property.</p> <ol> <li><code>dataBinding</code>: A path to a list in the data model (e.g., <code>/user/posts</code>).</li> <li><code>componentId</code>: The <code>id</code> of another component in the buffer to use as a template for each item in the list.</li> </ol> <p>The client will iterate over the list at <code>dataBinding</code> and, for each item, render the component specified by <code>componentId</code>. The item's data is made available to the template component for relative data binding.</p>"},{"location":"specification/v0.8-a2ui/#section-4-dynamic-data-state-management","title":"Section 4: Dynamic Data &amp; State Management","text":"<p>A2UI enforces a clean separation between the UI's structure (components) and its dynamic data (data model).</p>"},{"location":"specification/v0.8-a2ui/#41-the-datamodelupdate-message","title":"4.1. The <code>dataModelUpdate</code> Message","text":"<p>This message is the only way to modify the client's data model.</p> <ul> <li><code>surfaceId</code>: The unique identifier for the UI surface this data model update applies to.</li> <li><code>path</code>: An optional path to a location within the data model (e.g., '/user/name'). If omitted, the update applies to the root of the data model.</li> <li><code>contents</code>: An array of data entries arranged as an adjacency list. Each entry must contain a 'key' and exactly one corresponding typed 'value*' property (e.g. <code>valueString</code>, <code>valueNumber</code>, <code>valueBoolean</code>, <code>valueMap</code>).</li> <li><code>valueMap</code>: A JSON object representing a map as an adjacency list.</li> </ul>"},{"location":"specification/v0.8-a2ui/#example-updating-the-data-model","title":"Example: Updating the data model","text":"<pre><code>{\n  \"dataModelUpdate\": {\n    \"surfaceId\": \"main_content_area\",\n    \"path\": \"user\",\n    \"contents\": [\n      { \"key\": \"name\", \"valueString\": \"Bob\" },\n      { \"key\": \"isVerified\", \"valueBoolean\": true },\n      {\n        \"key\": \"address\",\n        \"valueMap\": [\n          { \"key\": \"street\", \"valueString\": \"123 Main St\" },\n          { \"key\": \"city\", \"valueString\": \"Anytown\" }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"specification/v0.8-a2ui/#42-data-binding-the-boundvalue-object","title":"4.2. Data Binding (The <code>BoundValue</code> Object)","text":"<p>Components connect to the data model through binding. Any property that can be data-bound (like <code>text</code> on a <code>Text</code> component) accepts a <code>BoundValue</code> object. This object defines either a literal value, a data path, or both as a shorthand for initialization.</p> <p>From the catalog schema, a bound <code>text</code> property looks like this:</p> <pre><code>{\n  \"type\": \"object\",\n  \"description\": \"A value that can be either a literal string or bound to the data model.\",\n  \"properties\": {\n    \"literalString\": {\n      \"type\": \"string\",\n      \"description\": \"A static string value.\"\n    },\n    \"path\": { \"$ref\": \"#/definitions/DataPath\" }\n  },\n  \"minProperties\": 1,\n  \"additionalProperties\": false\n}\n</code></pre> <p>A component can also bind to numbers (<code>literalNumber</code>), booleans (<code>literalBoolean</code>), or arrays (<code>literalArray</code>). The behavior depends on which properties are provided:</p> <ul> <li>Literal Value Only: If only a <code>literal*</code> value (e.g., <code>literalString</code>) is provided, the value is static and displayed directly.</li> </ul> <pre><code>\"text\": { \"literalString\": \"Hello\" }\n</code></pre> <ul> <li>Path Only: If only <code>path</code> is provided, the value is dynamic. It's resolved from the data model at render time.</li> </ul> <pre><code>\"text\": { \"path\": \"/user/name\" }\n</code></pre> <ul> <li> <p>Path and Literal Value (Initialization Shorthand): If both <code>path</code> and a <code>literal*</code> value are provided, it serves as a shorthand for data model initialization. The client MUST:</p> </li> <li> <p>Update the data model at the specified <code>path</code> with the provided <code>literal*</code> value. This is an implicit <code>dataModelUpdate</code>.</p> </li> <li>Bind the component property to that <code>path</code> for rendering and future updates.</li> </ul> <p>This allows the server to set a default value and bind to it in a single step.</p> <pre><code>// This initializes data model at '/user/name' to \"Guest\" and binds to it.\n\"text\": { \"path\": \"/user/name\", \"literalString\": \"Guest\" }\n</code></pre> <p>The client's interpreter is responsible for resolving these paths against the data model before rendering. The A2UI protocol supports direct 1:1 binding; it does not include transformers (e.g., formatters, conditionals). Any data transformation must be performed by the server before sending it in a <code>dataModelUpdate</code>.</p>"},{"location":"specification/v0.8-a2ui/#section-5-event-handling","title":"Section 5: Event Handling","text":"<p>While the server-to-client UI definition is a one-way stream (e.g., over SSE), user interactions are communicated back to the server using an A2A message.</p>"},{"location":"specification/v0.8-a2ui/#51-the-client-event-message","title":"5.1. The Client Event Message","text":"<p>The client sends a single JSON object that acts as a wrapper. It must contain exactly one of the following keys: <code>userAction</code> or <code>error</code>.</p>"},{"location":"specification/v0.8-a2ui/#52-the-useraction-message","title":"5.2. The <code>userAction</code> Message","text":"<p>This message is sent when the user interacts with a component that has an action defined. It is the primary mechanism for user-driven events.</p> <p>The <code>userAction</code> object has the following structure:</p> <ul> <li><code>name</code> (string, required): The name of the action, taken directly from the <code>action.name</code> property of the component (e.g., \"submit_form\").</li> <li><code>surfaceId</code> (string, required): The <code>id</code> of the surface where the event originated.</li> <li><code>sourceComponentId</code> (string, required): The <code>id</code> of the component that triggered the event (e.g., \"my_button\").</li> <li><code>timestamp</code> (string, required): An ISO 8601 timestamp of when the event occurred (e.g., \"2025-09-19T17:01:00Z\").</li> <li><code>context</code> (object, required): A JSON object containing the key-value pairs from the component's <code>action.context</code>, after resolving all <code>BoundValue</code>s against the data model.</li> </ul> <p>The process for resolving the <code>action.context</code> remains the same: the client iterates over the <code>context</code> array, resolves all literal or data-bound values, and constructs the <code>context</code> object.</p>"},{"location":"specification/v0.8-a2ui/#53-the-error-message","title":"5.3. The <code>error</code> Message","text":"<p>This message provides a feedback mechanism for the server. It is sent when the client encounters an error, for instance, during UI rendering or data binding. The content of the object is flexible and can contain any relevant error information.</p>"},{"location":"specification/v0.8-a2ui/#54-event-flow-example-useraction","title":"5.4. Event Flow Example (<code>userAction</code>)","text":"<ol> <li> <p>Component Definition (from <code>surfaceUpdate</code>):</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main_content_area\",\n    \"components\": [\n      {\n        \"id\": \"submit_btn_text\",\n        \"component\": {\n          \"Text\": {\n            \"text\": { \"literalString\": \"Submit\" }\n          }\n        }\n      },\n      {\n        \"id\": \"submit_btn\",\n        \"component\": {\n          \"Button\": {\n            \"child\": \"submit_btn_text\",\n            \"action\": {\n              \"name\": \"submit_form\",\n              \"context\": [\n                {\n                  \"key\": \"userInput\",\n                  \"value\": { \"path\": \"/form/textField\" }\n                },\n                { \"key\": \"formId\", \"value\": { \"literalString\": \"f-123\" } }\n              ]\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> </li> <li> <p>Data Model (from <code>dataModelUpdate</code>):</p> <pre><code>{\n  \"dataModelUpdate\": {\n    \"surfaceId\": \"main_content_area\",\n    \"path\": \"form\",\n    \"contents\": [{ \"key\": \"textField\", \"valueString\": \"User input text\" }]\n  }\n}\n</code></pre> </li> <li> <p>User Action: The user taps the \"submit_btn\" button.</p> </li> <li>Client-Side Resolution: The client resolves the <code>action.context</code>.</li> <li> <p>Client-to-Server Request: The client sends a <code>POST</code> request to <code>https://api.example.com/handle_event</code> with the following JSON body:</p> <pre><code>{\n  \"userAction\": {\n    \"name\": \"submit_form\",\n    \"surfaceId\": \"main_content_area\",\n    \"sourceComponentId\": \"submit_btn\",\n    \"timestamp\": \"2025-09-19T17:05:00Z\",\n    \"context\": {\n      \"userInput\": \"User input text\",\n      \"formId\": \"f-123\"\n    }\n  }\n}\n</code></pre> </li> <li> <p>Server Response: The server processes this event. If the UI needs to change as a result, the server sends new <code>surfaceUpdate</code> or <code>dataModelUpdate</code> messages over the separate SSE stream.</p> </li> </ol>"},{"location":"specification/v0.8-a2ui/#section-6-client-side-implementation","title":"Section 6: Client-Side Implementation","text":"<p>A robust client-side interpreter for A2UI should be composed of several key components:</p> <ul> <li>JSONL Parser: A parser capable of reading the stream line by line and decoding each line as a separate JSON object.</li> <li>Message Dispatcher: A mechanism (e.g., a <code>switch</code> statement) to identify the message type (<code>beginRendering</code>, <code>surfaceUpdate</code>, etc.) and route it to the correct handler.</li> <li>Component Buffer: A <code>Map&lt;String, Component&gt;</code> that stores all component instances by their <code>id</code>. This is populated by <code>componentUpdate</code> messages.</li> <li>Data Model Store: A <code>Map&lt;String, dynamic&gt;</code> (or similar) that holds the application state. This is built and modified by <code>dataModelUpdate</code> messages.</li> <li>Interpreter State: A state machine to track if the client is ready to render (e.g., a <code>_isReadyToRender</code> boolean that is set to <code>true</code> by <code>beginRendering</code>).</li> <li>Widget Registry: A developer-provided map (e.g., <code>Map&lt;String, WidgetBuilder&gt;</code>) that associates component type strings (\"Row\", \"Text\") with functions that build native widgets.</li> <li>Binding Resolver: A utility that can take a <code>BoundValue</code> (e.g., <code>{ \"path\": \"/user/name\" }</code>) and resolve it against the Data Model Store.</li> <li>Surface Manager: Logic to create, update, and delete UI surfaces based on <code>surfaceId</code>.</li> <li>Event Handler: A function, exposed to the <code>WidgetRegistry</code>, that constructs and sends the client event message (e.g., <code>userAction</code>) to the configured REST API endpoint.</li> </ul>"},{"location":"specification/v0.8-a2ui/#section-7-complete-a2ui-server-to-client-json-schema","title":"Section 7: Complete A2UI Server To Client JSON Schema","text":"<p>This section provides the formal JSON Schema for a single server-to-client message in the A2UI JSONL stream. Each line in the stream must be a valid JSON object that conforms to this schema. It includes the entire base catalog of components, but the components may be swapped out for other components supported by the client. It is optimized to be able to be generated in structured output mode from various LLMs.</p> <pre><code>{% include \"../specification/json/server_to_client_with_standard_catalog.json\" %}\n</code></pre>"},{"location":"specification/v0.8-a2ui/#section-8-complete-a2ui-client-to-server-json-schema","title":"Section 8: Complete A2UI Client to Server JSON Schema","text":"<p>This section provides the formal JSON Schema for a single client-to-server message in the A2UI protocol.</p> <pre><code>{% include \"../specification/json/client_to_server.json\" %}\n</code></pre>"},{"location":"specification/v0.9-a2ui/","title":"A2UI Protocol v0.9 (Draft)A2UI (Agent to UI) Protocol v0.9","text":"<p>Living Document</p> <p>This specification is automatically included from <code>specification/0.9/docs/a2ui_protocol.md</code>. Any updates to the specification will automatically appear here.</p> <p>Draft Status</p> <p>Version 0.9 is currently in draft status. For production use, consider v0.8 (Stable).</p> <p>See also: - v0.8 Protocol Specification (Stable) - Evolution Guide: v0.8 \u2192 v0.9</p> <p>A Specification for a JSON-Based, Streaming UI Protocol.</p> <p>Version: 0.9 Status: Draft Created: Nov 20, 2025 Last Updated: Dec 3, 2025</p> <p>A Specification for a JSON-Based, Streaming UI Protocol</p>"},{"location":"specification/v0.9-a2ui/#introduction","title":"Introduction","text":"<p>The A2UI Protocol is designed for dynamically rendering user interfaces from a stream of JSON objects sent from an A2A server. Its core philosophy emphasizes a clean separation of UI structure and application data, enabling progressive rendering as the client processes each message.</p> <p>Communication occurs via a stream of JSON objects. The client parses each object as a distinct message and incrementally builds or updates the UI. The server-to-client protocol defines four message types:</p> <ul> <li><code>createSurface</code>: Signals the client to create a new surface and begin rendering it.</li> <li><code>updateComponents</code>: Provides a list of component definitions to be added to or updated in a specific surface.</li> <li><code>updateDataModel</code>: Provides new data to be inserted into or to replace a surface's data model.</li> <li><code>deleteSurface</code>: Explicitly removes a surface and its contents from the UI.</li> </ul>"},{"location":"specification/v0.9-a2ui/#changes-from-previous-versions","title":"Changes from previous versions","text":"<p>Version 0.9 of the A2UI protocol represents a philosophical shift from previous versions. While v0.8 was optimized for LLMs that support structured output, v0.9 is designed to be embedded directly within a model's prompt. The LLM is then asked to produce JSON that matches the provided examples and schema descriptions.</p> <p>This \"prompt-first\" approach offers several advantages:</p> <ol> <li>Richer Schema: The protocol is no longer limited by the constraints of structured output formats. This allows for more readable, complex, and expressive component catalogs.</li> <li>Modularity: The schema is now refactored into separate, more manageable components (e.g., [<code>common_types.json</code>], [<code>standard_catalog_definition.json</code>], [<code>server_to_client.json</code>]), improving maintainability and modularity.</li> </ol> <p>The main disadvantage of this approach is that it requires more complex post-generation validation, as the LLM is not strictly constrained by the schema. This requires robust error handling and correction, so the system can identify discrepancies and attempt to fix them before rendering, or request a retry or correction from the LLM.</p>"},{"location":"specification/v0.9-a2ui/#protocol-overview-data-flow","title":"Protocol Overview &amp; Data Flow","text":"<p>The A2UI protocol uses a unidirectional stream of JSON messages from the server to the client to describe and update the UI. The client consumes this stream, builds the UI, and renders it. User interactions are handled separately, typically by sending events to a different endpoint, which may in turn trigger new messages on the UI stream.</p> <p>Here is an example sequence of events (which don't have to be in exactly this order):</p> <ol> <li>Create Surface: The server sends a <code>createSurface</code> message to initialize the surface.</li> <li>Update Surface: The server sends one or more <code>updateComponents</code> messages containing the definitions for all the components that will be part of the surface.</li> <li>Update Data Model: The server can send <code>updateDataModel</code> messages at any time to populate or change the data that the UI components will display.</li> <li>Render: The client renders the UI for the surface, using the component definitions to build the structure and the data model to populate the content.</li> <li>Dynamic Updates: As the user interacts with the application or as new information becomes available, the server can send additional <code>updateComponents</code> and <code>updateDataModel</code> messages to dynamically change the UI.</li> <li>Delete Surface: When a UI region is no longer needed, the server sends a <code>deleteSurface</code> message to remove it.</li> </ol> sequenceDiagram     participant Server     participant Client      Server-&gt;&gt;+Client: 1. createSurface(surfaceId: \"main\")     Server-&gt;&gt;+Client: 2. updateComponents(surfaceId: \"main\", components: [...])     Server-&gt;&gt;+Client: 2. updateDataModel(surfaceId: \"main\", op: \"replace\", value: {...})     Note right of Client: 3. Client renders the UI for the \"main\" surface     Client--&gt;&gt;-Server: (UI is displayed)     Client--&gt;&gt;-Server: (UI is displayed)      Note over Client, Server: Time passes, user interacts, or new data arrives...      Server-&gt;&gt;+Client: 4. updateComponents or updateDataModel (Dynamic Update)     Note right of Client: Client re-renders the UI to reflect changes     Client--&gt;&gt;-Server: (UI is updated)      Server-&gt;&gt;+Client: 5. deleteSurface(surfaceId: \"main\")     Note right of Client: Client removes the UI for the \"main\" surface     Client--&gt;&gt;-Server: (UI is gone)"},{"location":"specification/v0.9-a2ui/#the-protocol-schemas","title":"The Protocol Schemas","text":"<p>A2UI v0.9 is defined by three interacting JSON schemas.</p>"},{"location":"specification/v0.9-a2ui/#common-types","title":"Common Types","text":"<p>The [<code>common_types.json</code>] schema defines reusable primitives used throughout the protocol.</p> <ul> <li><code>stringOrPath</code> / <code>numberOrPath</code> / <code>booleanOrPath</code> / <code>stringArrayOrPath</code>: The core of the data binding system. Any property that can be bound to data is defined as an object that accepts either a literal value OR a <code>path</code> string (JSON Pointer).</li> <li> <p><code>childrenProperty</code>: Defines how containers hold children. It supports:</p> </li> <li> <p><code>array</code>: A static array of string component IDs.</p> </li> <li> <p><code>object</code>: A template for generating children from a data binding list (requires a template <code>componentId</code> and a data binding <code>path</code>).</p> </li> <li> <p><code>id</code>: The unique identifier for a component. Defined here so that all IDs are consistent and can be used for data binding.</p> </li> <li><code>weight</code>: The relative weight of a component within a Row or Column. This corresponds to the CSS 'flex-grow' property. Note: this may ONLY be set when the component is a direct descendant of a Row or Column. Defined here so that all weights are consistent and can be used for data binding.</li> </ul>"},{"location":"specification/v0.9-a2ui/#server-to-client-message-structure-the-envelope","title":"Server to Client Message Structure: The Envelope","text":"<p>The [<code>server_to_client.json</code>] schema is the top-level entry point. Every line streamed by the server must validate against this schema. It handles the message dispatching.</p>"},{"location":"specification/v0.9-a2ui/#the-standard-catalog","title":"The Standard Catalog","text":"<p>The [<code>standard_catalog_definition.json</code>] schema contains the definitions for all specific UI components (e.g., <code>Text</code>, <code>Button</code>, <code>Row</code>). By separating this from the envelope, developers can easily swap in custom catalogs (e.g., <code>material_catalog.json</code> or <code>cupertino_catalog.json</code>) without rewriting the core protocol parser.</p> <p>Custom catalogs can be used to define additional UI components or modify the behavior of existing components. To use a custom catalog, simply include it in the prompt in place of the standard catalog. It should have the same form as the standard catalog, and use common elements in the [<code>common_types.json</code>] schema.</p>"},{"location":"specification/v0.9-a2ui/#envelope-message-structure","title":"Envelope Message Structure","text":"<p>The envelope defines four primary message types, and every message streamed by the server must be a JSON object containing exactly one of the following keys: <code>createSurface</code>, <code>updateComponents</code>, <code>updateDataModel</code>, or <code>deleteSurface</code>. The key indicates the type of message, and these are the messages that make up each message in the protocol stream.</p>"},{"location":"specification/v0.9-a2ui/#createsurface","title":"<code>createSurface</code>","text":"<p>This message signals the client to create a new surface and begin rendering it. This message MUST be sent before the first <code>updateComponents</code> message that references this <code>surfaceId</code>. One of the components in one of the components lists MUST have an <code>id</code> of <code>root</code> to serve as the root of the component tree.</p> <p>Properties:</p> <ul> <li><code>surfaceId</code> (string, required): The unique identifier for the UI surface to be rendered.</li> <li><code>catalogId</code> (string, required): A string that uniquely identifies the component catalog used for this surface. It is recommended to prefix this with an internet domain that you own, to avoid conflicts (e.g., <code>https://mycompany.com/1.0/somecatalog</code>).</li> </ul> <p>Example:</p> <pre><code>{\n  \"createSurface\": {\n    \"surfaceId\": \"user_profile_card\",\n    \"catalogId\": \"https://a2ui.dev/specification/0.9/standard_catalog_definition.json\"\n  }\n}\n</code></pre>"},{"location":"specification/v0.9-a2ui/#updatecomponents","title":"<code>updateComponents</code>","text":"<p>This message provides a list of UI components to be added to or updated within a specific surface. The components are provided as a flat list, and their relationships are defined by ID references in an adjacency list. This message may not be sent until after a <code>createSurface</code> message that references this <code>surfaceId</code> has been sent.</p> <p>Properties:</p> <ul> <li><code>surfaceId</code> (string, required): The unique identifier for the UI surface to be updated. This is typically a name with meaning (e.g. \"user_profile_card\"), and it has to be unique within the context of the GenUI session.</li> <li><code>components</code> (array, required): A list of component objects. The components are provided as a flat list, and their relationships are defined by ID references in an adjacency list.</li> </ul> <p>Example:</p> <pre><code>{\n  \"updateComponents\": {\n    \"surfaceId\": \"user_profile_card\",\n    \"components\": [\n      {\n        \"id\": \"root\",\n        \"component\": \"Column\",\n        \"children\": [\"user_name\", \"user_title\"]\n      },\n      {\n        \"id\": \"user_name\",\n        \"component\": \"Text\",\n        \"text\": \"John Doe\"\n      },\n      {\n        \"id\": \"user_title\",\n        \"component\": \"Text\",\n        \"text\": \"Software Engineer\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"specification/v0.9-a2ui/#updatedatamodel","title":"<code>updateDataModel</code>","text":"<p>This message is used to send or update the data that populates the UI components. It allows the server to change the UI's content without resending the entire component structure.</p> <p>Properties:</p> <ul> <li><code>surfaceId</code> (string, required): The unique identifier for the UI surface this data model update applies to.</li> <li><code>path</code> (string, optional): A JSON Pointer to a specific location within the data model (e.g., <code>/user/name</code>). If omitted or set to <code>/</code>, the entire data model for the surface will be replaced.</li> <li><code>op</code> (string, optional): The operation to perform on the data model. Must be 'add', 'replace' or 'remove'. If omitted, defaults to 'replace'.</li> <li><code>value</code> (object): The data to be updated in the data model. This can be any valid JSON object. Required if <code>op</code> is 'add' or 'replace'. Not allowed if <code>op</code> is 'remove'.</li> </ul> <p>Example:</p> <pre><code>{\n  \"updateDataModel\": {\n    \"surfaceId\": \"user_profile_card\",\n    \"path\": \"/user\",\n    \"op\": \"replace\",\n    \"value\": {\n      \"name\": \"Jane Doe\",\n      \"title\": \"Software Engineer\"\n    }\n  }\n}\n</code></pre>"},{"location":"specification/v0.9-a2ui/#deletesurface","title":"<code>deleteSurface</code>","text":"<p>This message instructs the client to remove a surface and all its associated components and data from the UI.</p> <p>Properties:</p> <ul> <li><code>surfaceId</code> (string, required): The unique identifier for the UI surface to be deleted.</li> </ul> <p>Example:</p> <pre><code>{\n  \"deleteSurface\": {\n    \"surfaceId\": \"user_profile_card\"\n  }\n}\n</code></pre>"},{"location":"specification/v0.9-a2ui/#example-stream","title":"Example Stream","text":"<p>The following example demonstrates a complete interaction to render a Contact Form, expressed as a JSONL stream.</p> <pre><code>{\"createSurface\":{\"surfaceId\":\"contact_form_1\",\"catalogId\":\"https://a2ui.dev/specification/0.9/standard_catalog_definition.json\"}}\n{\"updateComponents\":{\"surfaceId\":\"contact_form_1\",\"components\":[{\"id\":\"root\",\"component\":\"Column\",\"children\":[\"first_name_label\",\"first_name_field\",\"last_name_label\",\"last_name_field\",\"email_label\",\"email_field\",\"phone_label\",\"phone_field\",\"notes_label\",\"notes_field\",\"submit_button\"]},{\"id\":\"first_name_label\",\"component\":\"Text\",\"text\":\"First Name\"},{\"id\":\"first_name_field\",\"component\":\"TextField\",\"label\":\"First Name\",\"text\":{\"path\":\"/contact/firstName\"},\"usageHint\":\"shortText\"},{\"id\":\"last_name_label\",\"component\":\"Text\",\"text\":\"Last Name\"},{\"id\":\"last_name_field\",\"component\":\"TextField\",\"label\":\"Last Name\",\"text\":{\"path\":\"/contact/lastName\"},\"usageHint\":\"shortText\"},{\"id\":\"email_label\",\"component\":\"Text\",\"text\":\"Email\"},{\"id\":\"email_field\",\"component\":\"TextField\",\"label\":\"Email\",\"text\":{\"path\":\"/contact/email\"},\"usageHint\":\"shortText\"},{\"id\":\"phone_label\",\"component\":\"Text\",\"text\":\"Phone\"},{\"id\":\"phone_field\",\"component\":\"TextField\",\"label\":\"Phone\",\"text\":{\"path\":\"/contact/phone\"},\"usageHint\":\"shortText\"},{\"id\":\"notes_label\",\"component\":\"Text\",\"text\":\"Notes\"},{\"id\":\"notes_field\",\"component\":\"TextField\",\"label\":\"Notes\",\"text\":{\"path\":\"/contact/notes\"},\"usageHint\":\"longText\"},{\"id\":\"submit_button_label\",\"component\":\"Text\",\"text\":\"Submit\"},{\"id\":\"submit_button\",\"component\":\"Button\",\"child\":\"submit_button_label\",\"action\":{\"name\":\"submitContactForm\"}}]}}\n{\"updateDataModel\": {\"surfaceId\": \"contact_form_1\", \"path\": \"/contact\", \"op\": \"replace\", \"value\": {\"firstName\": \"John\", \"lastName\": \"Doe\", \"email\": \"john.doe@example.com\"}}}\n</code></pre>"},{"location":"specification/v0.9-a2ui/#component-model","title":"Component Model","text":"<p>A2UI's component model is designed for flexibility, separating the protocol's structure from the set of available UI components.</p>"},{"location":"specification/v0.9-a2ui/#the-component-object","title":"The Component Object","text":"<p>Each object in the <code>components</code> array of a <code>updateComponents</code> message defines a single UI component. It has the following structure:</p> <ul> <li><code>id</code> (string, required): A unique string that identifies this specific component instance. This is used for parent-child references.</li> <li><code>weight</code> (number, optional): The relative weight of this component within a <code>Row</code> or <code>Column</code>, corresponding to the CSS <code>flex-grow</code> property.</li> <li><code>component</code> (string, required): Specifies the component's type (e.g., <code>\"Text\"</code>).</li> <li>Component Properties: Other properties relevant to the specific component type (e.g., <code>text</code>, <code>url</code>, <code>children</code>) are included directly in the component object.</li> </ul> <p>This structure is designed to be both flexible and strictly validated.</p>"},{"location":"specification/v0.9-a2ui/#the-component-catalog","title":"The Component Catalog","text":"<p>The set of available UI components and their properties is defined in a Component Catalog. The standard catalog is defined in [<code>standard_catalog_definition.json</code>]. This allows for different clients to support different sets of components, including custom ones. The server must generate <code>updateComponents</code> messages that conform to the component catalog understood by the client.</p>"},{"location":"specification/v0.9-a2ui/#ui-composition-the-adjacency-list-model","title":"UI Composition: The Adjacency List Model","text":"<p>The A2UI protocol defines the UI as a flat list of components. The tree structure is built implicitly using ID references. This is known as an adjacency list model.</p> <p>Container components (like <code>Row</code>, <code>Column</code>, <code>List</code>, and <code>Card</code>) have properties that reference the <code>id</code> of their child component(s). The client is responsible for storing all components in a map (e.g., <code>Map&lt;String, Component&gt;</code>) and recreating the tree structure at render time.</p> <p>This model allows the server to send component definitions in any order, as long as all necessary components are present before rendering is triggered.</p> <p>There must be exactly one component with the ID <code>root</code> in the component tree, acting as the root of the component tree. Until that component is defined, other component updates will have no visible effect, and they will be buffered until a root component is defined. Once a root component is defined, the client is responsible for rendering the tree in the best way possible based on the available data, skipping invalid references.</p> flowchart TD     subgraph \"Server Stream\"         A(\"updateComponentscomponents: [root, title, button]\")     end      subgraph \"Client-Side Buffer (Map)\"         C(\"root: {id: 'root', component: 'Column', children: ['title', 'button']}\")         D(\"title: {id: 'title', component: 'Text', text: 'Welcome'}\")         E(\"button: {id: 'button', component: 'Button', child: 'button_label'}\")     end      subgraph \"Rendered Widget Tree\"         F(Column) --&gt; G(Text: 'Welcome')         F --&gt; H(Button)     end      A -- \"Parsed and stored\" --&gt; C     A -- \"Parsed and stored\" --&gt; D     A -- \"Parsed and stored\" --&gt; E"},{"location":"specification/v0.9-a2ui/#data-binding-scope-and-state-management","title":"Data Binding, Scope, and State Management","text":"<p>A2UI relies on a strictly defined relationship between the UI structure (Components) and the state (Data Model). This section defines the precise mechanics of path resolution, variable scope during iteration, and the specific behaviors of two-way binding for interactive components.</p>"},{"location":"specification/v0.9-a2ui/#path-resolution-scope","title":"Path Resolution &amp; Scope","text":"<p>Data bindings in A2UI are defined using JSON Pointers (RFC 6901). How a pointer is resolved depends on the current Evaluation Scope.</p>"},{"location":"specification/v0.9-a2ui/#the-root-scope","title":"The Root Scope","text":"<p>By default, all components operate in the Root Scope.</p> <ul> <li>The Root Scope corresponds to the top-level object of the <code>value</code> provided in <code>updateDataModel</code>.</li> <li>Paths starting with <code>/</code> (e.g., <code>/user/profile/name</code>) are Absolute Paths. They always resolve from the root of the Data Model, regardless of where the component is nested in the UI tree.</li> </ul>"},{"location":"specification/v0.9-a2ui/#collection-scopes-relative-paths","title":"Collection Scopes (Relative Paths)","text":"<p>When a container component (such as <code>Column</code>, <code>Row</code>, or <code>List</code>) utilizes the Template feature of <code>childrenProperty</code>, it creates a new Child Scope for each item in the bound array.</p> <ul> <li>Template Definition: When a container binds its children to a path (e.g., <code>path: \"/users\"</code>), the client iterates over the array found at that location.</li> <li>Scope Instantiation: For every item in the array, the client instantiates the template component.</li> <li> <p>Relative Resolution: Inside these instantiated components, any path that does not start with a forward slash <code>/</code> is treated as a Relative Path.</p> </li> <li> <p>A relative path <code>firstName</code> inside a template iterating over <code>/users</code> resolves to <code>/users/0/firstName</code> for the first item, <code>/users/1/firstName</code> for the second, etc.</p> </li> <li> <p>Mixing Scopes: Components inside a Child Scope can still access the Root Scope by using an Absolute Path.</p> </li> </ul>"},{"location":"specification/v0.9-a2ui/#example-scope-resolution","title":"Example: Scope Resolution","text":"<p>Data Model:</p> <pre><code>{\n  \"company\": \"Acme Corp\",\n  \"employees\": [\n    { \"name\": \"Alice\", \"role\": \"Engineer\" },\n    { \"name\": \"Bob\", \"role\": \"Designer\" }\n  ]\n}\n</code></pre> <p>Component Definition:</p> <pre><code>{\n  \"id\": \"employee_list\",\n  \"component\": \"List\",\n  \"children\": {\n    \"path\": \"/employees\",\n    \"componentId\": \"employee_card_template\"\n  }\n},\n{\n  \"id\": \"employee_card_template\",\n  \"component\": \"Column\",\n  \"children\": [\"name_text\", \"company_text\"]\n},\n{\n  \"id\": \"name_text\",\n  \"component\": \"Text\",\n  \"text\": { \"path\": \"name\" }\n  // \"name\" is Relative. Resolves to /employees/N/name\n},\n{\n  \"id\": \"company_text\",\n  \"component\": \"Text\",\n  \"text\": { \"path\": \"/company\" }\n  // \"/company\" is Absolute. Resolves to \"Acme Corp\" globally.\n}\n</code></pre>"},{"location":"specification/v0.9-a2ui/#two-way-binding-input-components","title":"Two-Way Binding &amp; Input Components","text":"<p>Interactive components that accept user input (<code>TextField</code>, <code>CheckBox</code>, <code>Slider</code>, <code>MultipleChoice</code>, <code>DateTimeInput</code>) establish a Two-Way Binding with the Data Model.</p>"},{"location":"specification/v0.9-a2ui/#the-readwrite-contract","title":"The Read/Write Contract","text":"<p>Unlike static display components (like <code>Text</code>), input components modify the client-side data model immediately upon user interaction.</p> <ol> <li>Read (Model -&gt; View): When the component renders, it reads its value from the bound <code>path</code>. If the Data Model is updated via <code>updateDataModel</code>, the component re-renders to reflect the new value.</li> <li>Write (View -&gt; Model): When the user interacts with the component (e.g., types a character, toggles a box), the client immediately updates the value at the bound <code>path</code> in the local Data Model.</li> </ol>"},{"location":"specification/v0.9-a2ui/#reactivity","title":"Reactivity","text":"<p>Because the local Data Model is the single source of truth, updates from input components are reactive.</p> <ul> <li>If a <code>TextField</code> is bound to <code>/user/name</code>, and a separate <code>Text</code> label is also bound to <code>/user/name</code>, the label must update in real-time as the user types in the text field.</li> </ul>"},{"location":"specification/v0.9-a2ui/#server-synchronization","title":"Server Synchronization","text":"<p>It is critical to note that Two-Way Binding is local to the client.</p> <ul> <li>User inputs (keystrokes, toggles) do not automatically trigger network requests to the server.</li> <li>The updated state is sent to the server only when a specific User Action is triggered (e.g., a <code>Button</code> click).</li> <li>When a <code>userAction</code> is dispatched, the <code>context</code> property of the action can reference the modified data paths to send the user's input back to the server.</li> </ul>"},{"location":"specification/v0.9-a2ui/#example-form-submission-pattern","title":"Example: Form Submission Pattern","text":"<ol> <li>Bind: <code>TextField</code> is bound to <code>/formData/email</code>.</li> <li>Interact: User types \"jane@example.com\". The local model at <code>/formData/email</code> is updated.</li> <li> <p>Action: A \"Submit\" button has the following action definition:</p> <pre><code>\"action\": {\n  \"name\": \"submit_form\",\n  \"context\": {\n    \"email\": { \"path\": \"/formData/email\" }\n  }\n}\n</code></pre> </li> <li> <p>Send: When clicked, the client resolves <code>/formData/email</code> (getting \"jane@example.com\") and sends it in the <code>userAction</code> payload.</p> </li> </ol>"},{"location":"specification/v0.9-a2ui/#standard-component-catalog","title":"Standard Component Catalog","text":"<p>The [<code>standard_catalog_definition.json</code>] provides the baseline set of components.</p> Component Description Text Displays text. Supports simple Markdown. Image Displays an image from a URL. Icon Displays a system-provided icon from a predefined list. Video Displays a video from a URL. AudioPlayer A player for audio content from a URL. Row A horizontal layout container. Column A vertical layout container. List A scrollable list of components. Card A container with card-like styling. Tabs A set of tabs, each with a title and child component. Divider A horizontal or vertical dividing line. Modal A dialog that appears over the main content triggered by a button in the main content. Button A clickable button that dispatches an action. CheckBox A checkbox with a label and a boolean value. TextField A field for user text input. DateTimeInput An input for date and/or time. ChoicePicker A component for selecting one or more options. Slider A slider for selecting a numeric value within a range."},{"location":"specification/v0.9-a2ui/#usage-pattern-the-prompt-generate-validate-loop","title":"Usage Pattern: The Prompt-Generate-Validate Loop","text":"<p>The A2UI protocol is designed to be used in a three-step loop with a Large Language Model:</p> <ol> <li> <p>Prompt: Construct a prompt for the LLM that includes:</p> <ul> <li>The desired UI to be generated.</li> <li>The A2UI JSON schema, including the component catalog.</li> <li>Examples of valid A2UI JSON.</li> </ul> </li> <li> <p>Generate: Send the prompt to the LLM and receive the generated JSON output.</p> </li> <li> <p>Validate: Validate the generated JSON against the A2UI schema. If the JSON is valid, it can be sent to the client for rendering. If it is invalid, the errors can be reported back to the LLM in a subsequent prompt, allowing it to self-correct.</p> </li> </ol> <p>This loop allows for a high degree of flexibility and robustness, as the system can leverage the generative capabilities of the LLM while still enforcing the structural integrity of the UI protocol.</p>"},{"location":"specification/v0.9-a2ui/#standard-validation-error-format","title":"Standard Validation Error Format","text":"<p>If validation fails, the client (or the system acting on behalf of the client) should send an <code>error</code> message back to the LLM. To ensure the LLM can understand and correct the error, use the following standard format within the <code>error</code> message payload:</p> <ul> <li><code>code</code> (string, required): Must be <code>\"VALIDATION_FAILED\"</code>.</li> <li><code>surfaceId</code> (string, required): The ID of the surface where the error occurred.</li> <li><code>path</code> (string, required): The JSON pointer to the field that failed validation (e.g. <code>/components/0/text</code>).</li> <li><code>message</code> (string, required): A short one-sentence description of why validation failed.</li> </ul> <p>Example Error Message:</p> <pre><code>{\n  \"error\": {\n    \"code\": \"VALIDATION_FAILED\",\n    \"surfaceId\": \"user_profile_card\",\n    \"path\": \"/components/0/text\",\n    \"message\": \"Expected stringOrPath, got integer\"\n  }\n}\n</code></pre>"},{"location":"specification/v0.9-a2ui/#client-to-server-messages","title":"Client-to-Server Messages","text":"<p>The protocol also defines messages that the client can send to the server, which are defined in the [<code>client_to_server.json</code>] schema. These are used for handling user interactions and reporting client-side information.</p>"},{"location":"specification/v0.9-a2ui/#useraction","title":"<code>userAction</code>","text":"<p>This message is sent when the user interacts with a component that has an <code>action</code> defined, such as a <code>Button</code>.</p> <p>Properties:</p> <ul> <li><code>name</code> (string, required): The name of the action.</li> <li><code>surfaceId</code> (string, required): The ID of the surface where the action originated.</li> <li><code>sourceComponentId</code> (string, required): The ID of the component that triggered the action.</li> <li><code>timestamp</code> (string, required): An ISO 8601 timestamp.</li> <li><code>context</code> (object, required): A JSON object containing any context provided in the component's <code>action</code> property.</li> </ul>"},{"location":"specification/v0.9-a2ui/#error","title":"<code>error</code>","text":"<p>This message is used to report a client-side error to the server.</p>"},{"location":"specification/v0.9-evolution-guide/","title":"Evolution Guide: v0.8 \u2192 v0.9","text":"<p>Living Document</p> <p>This guide is automatically included from <code>specification/0.9/docs/evolution_guide.md</code>. Any updates will automatically appear here.</p> <p>Related Documentation: - A2UI Protocol v0.8 (Stable - what you're migrating from) - A2UI Protocol v0.9 (Draft - what you're migrating to)</p>"},{"location":"specification/v0.9-evolution-guide/#a2ui-protocol-evolution-guide-v081-to-v09","title":"A2UI Protocol Evolution Guide: v0.8.1 to v0.9","text":"<p>This document serves as a comprehensive guide to the changes between A2UI version 0.8 and version 0.9. It details the shifts in philosophy, architecture, and implementation, providing a reference for stakeholders and developers migrating between versions.</p>"},{"location":"specification/v0.9-evolution-guide/#1-executive-summary","title":"1. Executive Summary","text":"<p>Version 0.9 represents a fundamental philosophical shift from \"Structured Output First\" to \"Prompt First.\"</p> <ul> <li>v0.8.1 was designed to be generated by an LLM using Structured Output above all else, optimized for LLMs that support strict JSON mode or function calling (which is also a form of Structured Output). It relied on deep nesting and specific wrapper structures that were definable in the limited schema features but often confusing for an LLM to generate.</li> <li>v0.9 is designed to be embedded directly in an LLM's system prompt. The schema is refactored to be more human-readable and \"token-efficient\" for the model to understand. It prioritizes patterns that LLMs naturally excel at (like standard JSON objects for maps) over strict structured output-friendly structures (like arrays of key-value pairs).</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#summary-table","title":"Summary Table","text":"Feature v0.8.1 v0.9 Philosophy Structured Output / Function Calling Prompt-First / In-Context Schema Message Types <code>beginRendering</code>, <code>surfaceUpdate</code>, ... <code>createSurface</code>, <code>updateComponents</code>, ... Surface Creation Explicit <code>beginRendering</code> Explicit <code>createSurface</code> Component Type Key-based wrapper (<code>{\"Text\": ...}</code>) Property-based discriminator (<code>\"component\": \"Text\"</code>) Data Model Update Array of Key-Value Pairs Standard JSON Object Data Binding <code>dataBinding</code> / <code>literalString</code> <code>path</code> / Native JSON types Button Context Array of Key-Value pairs Standard JSON Object Auxiliary Rules N/A <code>standard_catalog_rules.txt</code> Validation Basic Schema Strict <code>ValidationFailed</code> feedback loop"},{"location":"specification/v0.9-evolution-guide/#2-architectural-schema-changes","title":"2. Architectural &amp; Schema Changes","text":""},{"location":"specification/v0.9-evolution-guide/#21-modular-schema-architecture","title":"2.1. Modular Schema Architecture","text":"<p>v0.8.1:</p> <ul> <li>Monolithic tendencies. <code>server_to_client.json</code> often contained deep definitions or relied on complex <code>oneOf</code> structures that were hard to decompose.</li> <li><code>standard_catalog_definition.json</code> existed but was often implicitly coupled.</li> </ul> <p>v0.9:</p> <ul> <li>Modularization: The schema is strictly split into:</li> <li><code>common_types.json</code>: Reusable primitives (IDs, paths, weights).</li> <li><code>server_to_client.json</code>: The \"envelope\" defining the message types.</li> <li><code>standard_catalog_definition.json</code>: The specific UI components.</li> <li>Benefit: This allows developers to swap out the <code>standard_catalog_definition.json</code> for a <code>custom_catalog.json</code> without touching the core protocol envelope.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#22-strict-message-typing","title":"2.2. Strict Message Typing","text":"<p>v0.8.1:</p> <ul> <li>Messages were objects where properties like <code>surfaceUpdate</code> were optional keys.</li> <li>Validation often relied on \"minProperties: 1\" constraints.</li> </ul> <p>v0.9:</p> <ul> <li>Uses a top-level <code>oneOf</code> constraint in <code>server_to_client.json</code>.</li> <li>Reason: This is a more natural way to express the schema to an LLM, and easier for the LLM to reason about. It's also a more natural form for the developer to read.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#23-auxiliary-rules-file","title":"2.3. Auxiliary Rules File","text":"<p>v0.9:</p> <ul> <li>New Artifact: <code>standard_catalog_rules.txt</code>.</li> <li>Purpose: A plain-text prompt fragment containing rules for using the catalog schema (e.g., \"MUST provide 'action' for Button\").</li> <li>Usage: Designed to be included in the system prompt alongside the catalog schema.</li> <li>Reason: Some constraints (like conditional requirements or specific property combinations) are difficult or verbose to express in JSON Schema but easy to express in natural language rules for an LLM, and it can be packaged with the catalog schema for ease of customizing the prompt for a particular catalog.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#3-protocol-lifecycle-changes","title":"3. Protocol Lifecycle Changes","text":""},{"location":"specification/v0.9-evolution-guide/#31-beginrendering-replaced-by-createsurface","title":"3.1. <code>beginRendering</code> Replaced by <code>createSurface</code>","text":"<p>v0.8.1 (<code>beginRendering</code>):</p> <ul> <li>Explicit Signal: The server sent a <code>beginRendering</code> message to tell the client \"I am done sending the initial batch of components, you can draw now.\"</li> <li>Root Definition: The root component ID was defined in this message.</li> <li>Style Information: The message included style information for the surface.</li> </ul> <p>v0.9 (<code>createSurface</code>):</p> <ul> <li>Replacement: <code>beginRendering</code> is REPLACED by <code>createSurface</code>.</li> <li>Purpose: <code>createSurface</code> signals the client to create a new surface and prepare for rendering.</li> <li>Style Information Removed: <code>createSurface</code> does NOT contain style information. Theming is now handled via the client styles, decoupling it from the message stream.</li> <li>Root Rule: The rule is: \"There must be exactly one component with the ID <code>root</code>.\" The \"root\" attribute that <code>beginRendering</code> had has been removed. The client is expected to render as soon as it has a valid tree with a root component.</li> <li>New Requirement: <code>createSurface</code> now requires a <code>catalogId</code> (URI) to explicitly state which component set is being used.</li> </ul> <p>Example:</p> <p>v0.8.1 (<code>beginRendering</code>): <pre><code>{\n  \"beginRendering\": {\n    \"surfaceId\": \"user_profile_card\",\n    \"root\": \"root\",\n    \"styles\": {\n      \"primaryColor\": \"#007bff\",\n    }\n  }\n}\n</code></pre></p> <p>v0.9 (<code>createSurface</code>): <pre><code>{\n  \"createSurface\": {\n    \"surfaceId\": \"user_profile_card\",\n    \"catalogId\": \"https://a2ui.dev/specification/0.9/standard_catalog_definition.json\"\n  }\n}\n</code></pre></p>"},{"location":"specification/v0.9-evolution-guide/#4-message-structure-comparison","title":"4. Message Structure Comparison","text":""},{"location":"specification/v0.9-evolution-guide/#41-component-updates","title":"4.1. Component Updates","text":"<p>v0.8.1 (<code>surfaceUpdate</code>):</p> <ul> <li>Components were wrapped in an object where the key was the component type.</li> <li>Structure: <code>{ \"id\": \"...\", \"component\": { \"Text\": { \"text\": \"...\" } } }</code></li> </ul> <p>v0.9 (<code>updateComponents</code>):</p> <ul> <li>Renamed: <code>surfaceUpdate</code> -&gt; <code>updateComponents</code>.</li> <li>Refactored: Components use a flattened structure with a const discriminator property <code>component</code>.</li> <li>Structure: <code>{ \"id\": \"...\", \"component\": \"Text\", \"text\": \"...\" }</code></li> <li>Reason: This \"flat\" structure with a discriminator field (<code>component: \"Text\"</code>) is much easier for LLMs to generate consistently than a dynamic key (<code>\"Text\": {...}</code>). It also simplifies polymorphism in many JSON parsers.</li> </ul> <p>Specifying an unknown surfaceId will cause an error. It is recommended that clients implement a namespacing scheme internally to prevent separate agents from creating surfaces with the same ID, and to prevent agents from modifying surfaces created by other agents.</p>"},{"location":"specification/v0.9-evolution-guide/#side-by-side-example","title":"Side-by-Side Example","text":"<p>v0.8.1:</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main\",\n    \"components\": [\n      {\n        \"id\": \"title\",\n        \"component\": {\n          \"Text\": { \"text\": { \"literalString\": \"Hello\" } }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>v0.9:</p> <pre><code>{\n  \"updateComponents\": {\n    \"surfaceId\": \"main\",\n    \"components\": [\n      {\n        \"id\": \"root\",\n        \"component\": \"Column\",\n        \"children\": [\"title\"]\n      },\n      {\n        \"id\": \"title\",\n        \"component\": \"Text\",\n        \"text\": \"Hello\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"specification/v0.9-evolution-guide/#42-data-model-updates","title":"4.2. Data Model Updates","text":"<p>v0.8.1 (<code>dataModelUpdate</code>):</p> <ul> <li>Adjacency List: The <code>contents</code> property was an array of key-value pair objects.</li> <li>Typed Values: Each entry required explicit typing like <code>valueString</code>, <code>valueNumber</code>, <code>valueBoolean</code>.</li> <li>Structure: <code>[{ \"key\": \"name\", \"valueString\": \"Alice\" }]</code></li> </ul> <p>v0.9 (<code>updateDataModel</code>):</p> <ul> <li>Renamed: <code>dataModelUpdate</code> -&gt; <code>updateDataModel</code>.</li> <li>Standard JSON: The <code>value</code> property is now a standard JSON object.</li> <li>Op: The <code>op</code> property is added to allow for more complex updates (e.g., <code>replace</code>, <code>remove</code>).</li> <li>Structure: <code>{ \"name\": \"Alice\" }</code></li> <li>Reason: LLMs are trained to generate JSON objects. Forcing them to generate an \"adjacency list\" representation of a map was inefficient and error-prone.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#5-data-binding-state","title":"5. Data Binding &amp; State","text":""},{"location":"specification/v0.9-evolution-guide/#51-standardization-of-path","title":"5.1. Standardization of <code>path</code>","text":"<p>v0.8.1:</p> <ul> <li>Used <code>dataBinding</code> in <code>childrenProperty</code> templates.</li> <li>Used <code>path</code> in <code>BoundValue</code> objects.</li> <li>Inconsistent terminology.</li> </ul> <p>v0.9:</p> <ul> <li>Unified: Everything is now <code>path</code>.</li> <li>Reason: Reduces cognitive load for the LLM. \"Path\" always means \"JSON Pointer to data.\"</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#52-simplified-bound-values","title":"5.2. Simplified Bound Values","text":"<p>v0.8.1:</p> <ul> <li><code>{ \"literalString\": \"foo\" }</code> or <code>{ \"path\": \"/foo\" }</code>.</li> <li>Explicit typing in keys (<code>literalNumber</code>, <code>literalBoolean</code>).</li> </ul> <p>v0.9:</p> <ul> <li>Implicit Typing: <code>stringOrPath</code>, <code>numberOrPath</code>, etc. are defined in <code>common_types.json</code>.</li> <li>Structure: The schema allows <code>string</code> OR <code>{ \"path\": \"...\" }</code>.</li> <li>Reason: Much more natural JSON. <code>{ \"text\": \"Hello\" }</code> is valid. <code>{ \"text\": { \"path\": \"/msg\" } }</code> is valid. No need for <code>{ \"text\": { \"literalString\": \"Hello\" } }</code>.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#6-component-specific-changes","title":"6. Component-Specific Changes","text":""},{"location":"specification/v0.9-evolution-guide/#61-button-context","title":"6.1. Button Context","text":"<p>v0.8.1:</p> <ul> <li>Array of Pairs: <code>context: [{ \"key\": \"id\", \"value\": \"123\" }]</code></li> <li>Reason: Easy to parse, hard to generate.</li> </ul> <p>v0.9:</p> <ul> <li>Standard Map: <code>context: { \"id\": \"123\" }</code></li> <li>Reason: Token efficiency. LLMs understand JSON objects as maps natively.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#62-textfield","title":"6.2. TextField","text":"<p>v0.8.1:</p> <ul> <li>Property: <code>textFieldType</code> (e.g., \"email\", \"password\").</li> </ul> <p>v0.9:</p> <ul> <li>Property: <code>usageHint</code>.</li> <li>Reason: Consistency with <code>Text</code> and <code>Image</code> components which already used <code>usageHint</code>.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#63-choicepicker-vs-multiplechoice","title":"6.3. ChoicePicker (vs MultipleChoice)","text":"<p>v0.8.1:</p> <ul> <li>Component: <code>MultipleChoice</code>.</li> <li>Properties: <code>selections</code> (array), <code>maxAllowedSelections</code> (integer).</li> </ul> <p>v0.9:</p> <ul> <li>Component: <code>ChoicePicker</code>.</li> <li>Properties: <code>value</code> (array), <code>usageHint</code> (enum: <code>multipleSelection</code>, <code>mutuallyExclusive</code>). The <code>maxAllowedSelections</code> property was removed.</li> <li>Reason: <code>ChoicePicker</code> is a more generic name that covers both radio buttons (mutually exclusive) and checkboxes (multiple selection). The <code>usageHint</code> controls the behavior, simplifying the component surface area.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#64-slider","title":"6.4. Slider","text":"<p>v0.8.1:</p> <ul> <li>Properties: <code>minValue</code>, <code>maxValue</code>.</li> </ul> <p>v0.9:</p> <ul> <li>Properties: <code>min</code>, <code>max</code>.</li> <li>Reason: Standardizing on shorter, more common property names.</li> </ul>"},{"location":"specification/v0.9-evolution-guide/#7-error-handling","title":"7. Error Handling","text":"<p>v0.9 introduces a strict <code>ValidationFailed</code> error format in <code>client_to_server.json</code>.</p> <ul> <li>Purpose: To allow the \"Prompt-Generate-Validate\" loop to work effectively.</li> <li>Mechanism: If the LLM generates invalid JSON, the system sends back a structured error:   <pre><code>{\n  \"error\": {\n    \"code\": \"VALIDATION_FAILED\",\n    \"surfaceId\": \"...\",\n    \"path\": \"/components/0/text\",\n    \"message\": \"Expected string, got number\"\n  }\n}\n</code></pre></li> <li>Result: The LLM sees this and can \"self-correct\" in the next turn.</li> </ul>"}]}